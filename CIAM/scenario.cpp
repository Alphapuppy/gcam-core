/*! 
* \file scenario.cpp
* \ingroup CIAM
* \brief Scenario class source file.
* \author Sonny Kim
* \date $Date$
* \version $Revision$
*/				

#include "Definitions.h"
#include <string>
#include <iostream>
#include <fstream>
#include <cassert>
#include <ctime>
#include <xercesc/util/XMLString.hpp>
#include <xercesc/dom/DOM.hpp>
#include "scenario.h"
#include "modeltime.h"
#include "world.h"
#include "xmlHelper.h"
#include "Configuration.h"

using namespace std;

void climat_data(void); // function to write data for climat
#ifdef WIN32
extern "C" { void _stdcall CLIMAT(void); };
#endif

ofstream gasfile; // text file for climate input
extern time_t ltime;
extern ofstream logfile, sdcurvefile;

//! Default construtor
Scenario::Scenario() {
}

//! Clear all datamembers.
void Scenario::clear() {
	name = "";
	scenarioSummary = "";
}

//! Return a reference to the modeltime.
const Modeltime* Scenario::getModeltime() const {
	return &modeltime;
}

//! Return a constant reference to the goods and services marketplace.
const Marketplace* Scenario::getMarketplace() const {
	return &marketplace;
}

//! Return a mutable reference to the goods and services marketplace.
Marketplace* Scenario::getMarketplace() {
	return &marketplace;
}

//! Return a constant reference to the world object.
const World* Scenario::getWorld() const {
	return &world;
}

//! Return a mutable reference to the world object.
World* Scenario::getWorld() {
	return &world;
}

//! Set data members from XML input.
void Scenario::XMLParse( const DOMNode* node ){
	
	DOMNode* curr = 0;
	DOMNodeList* nodeList;
	string nodeName;
	
	// assume we were passed a valid node.
	assert( node );
	
	// set the scenario name
	name = XMLHelper<string>::getAttrString( node, "name" );
	
	// get the children of the node.
	nodeList = node->getChildNodes();
	
	// loop through the children
	for ( int i = 0; i < nodeList->getLength(); i++ ){
		curr = nodeList->item( i );
		nodeName = XMLHelper<string>::safeTranscode( curr->getNodeName() );
		
		if ( nodeName == "summary" ){
			scenarioSummary = XMLHelper<string>::getValueString( curr );
		}
		
		else if ( nodeName == "modeltime" ){
			modeltime.XMLParse( curr );
			modeltime.set(); // calculate time parameters and conversions
		}
		else if ( nodeName == "world" ){
			world.XMLParse( curr );
		}
	}
}

//! Write object to xml output stream.
void Scenario::toXML( ostream& out ) const {
	
	// write heading for XML input file
	bool header = true;
	if (header) {
		out << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" << endl;
		out << "<!-- edited with XMLSPY v5 rel. 2 U (http://www.xmlspy.com)";
		out << "by Son H. Kim (PNNL) -->" << endl;
		out << "<!--XML file generated by XMLSPY v5 rel. 2 U (http://www.xmlspy.com)-->" << endl;
	}
	
	string dateString = XMLCreateDate( ltime );
	out << "<scenario xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"";
	out << " xsi:noNamespaceSchemaLocation=\"C:\\PNNL\\CIAM\\CVS\\CIAM\\Ciam.xsd\"";
	out << " name=\"" << name << "\" date=\"" << dateString << "\">" << endl;
	
	// increase the indent.
	Tabs::increaseIndent();
	
	// summary notes on scenario
	Tabs::writeTabs( out );
	out << "<summary>\"SRES B2 Scenario is used for this Reference Scenario\"</summary>" << endl;
	
	// write the xml for the class members.
	modeltime.toXML( out );
	world.toXML( out );
	// finished writing xml for the class members.
	
	// decrease the indent.
	Tabs::decreaseIndent();
	
	// write the closing tag.
	Tabs::writeTabs( out );
	out << "</scenario>" << endl;
}

//! Write out object to output stream for debugging.
void Scenario::toDebugXMLOpen( const int period, ostream& out ) const {
	
	Tabs::writeTabs( out );
	string dateString = XMLCreateDate( ltime );
	out << "<scenario name=\"" << name << "\" date=\"" << dateString << "\">" << endl;
	
	Tabs::increaseIndent();
	Tabs::writeTabs( out );
	out << "<summary>\"Debugging output\"</summary>" << endl;
	
	// write the xml for the class members.
	modeltime.toDebugXML( period, out );
	world.toDebugXML( period, out );
	// finished writing xml for the class members.
	
}

//! Write out close scenario tag to output stream for debugging.
void Scenario::toDebugXMLClose( const int period, ostream& out ) const {
	
	// decrease the indent.
	Tabs::decreaseIndent();
	
	// write the closing tag.
	Tabs::writeTabs( out );
	out << "</scenario>" << endl;
}

//! Return scenario name.
string Scenario::getName() const {
	return name; 
}

//! Run the scenario
void Scenario::run(){
	
	Configuration* conf = Configuration::getInstance();
	ofstream xmlDebugStream;

	xmlDebugStream.open( conf->getFile( "xmlDebugFileName" ).c_str(), ios::out );
	gasfile.open( conf->getFile( "climatFileName" ).c_str(), ios::out );
	
	// set size of global arrays depending on MaxPer 
	// works fine with XMLParse, only calls maxper
	world.initper(); 
	
	// Start Model run for the first period.
	int per = 0;
   
   if ( conf->getBool( "CalibrationActive" ) ) {
	   world.setupCalibrationMarkets();
   }

	marketplace.initXMLPrices(); // initialize prices
	marketplace.nulldem( per ); // null market demands
	marketplace.nullsup( per ); // null market supply
	
	// Write scenario root element for the debugging.
	toDebugXMLOpen( per, xmlDebugStream );
	
	world.calc( per ); // Calculate supply and demand
	world.updateSummary( per ); // Update summaries for reporting
	world.sumpop( per ); // Calculate global population
	world.emiss_ind( per ); // Calculate global emissions
	world.sumrsc( per ); // Calculate global depletable resources
	
	cout << endl << "Period " << per <<": "<< modeltime.getper_to_yr(per) << endl;
	cout << "Period 0 not solved" << endl;
	logfile << "Period:  " << per << endl;
	// end of first period.
	
	// Loop over time steps and operate model
	for ( per = 1; per < modeltime.getmaxper(); per++ ) {	
		
		// Write out some info.
		cout << endl << "Period " << per <<": "<< modeltime.getper_to_yr( per ) << endl;
		logfile << "Period:  " << per << endl;
		sdcurvefile << "Period " << per << ": "<< modeltime.getper_to_yr( per ) << endl;
		sdcurvefile << "Market,Name,Price,Supply,Demand,";
		sdcurvefile << "Market,Name,Price,Supply,Demand,";
		sdcurvefile << "Market,Name,Price,Supply,Demand,";
		sdcurvefile << "Market,Name,Price,Supply,Demand,";
		sdcurvefile << "Market,Name,Price,Supply,Demand," << endl;
		
		// Run the iteration of the model.
		marketplace.nulldem( per ); // initialize market demand to null
		marketplace.nullsup( per ); // initialize market supply to null
		marketplace.storeto_last( per ); // save last period's info to stored variables
		marketplace.init_to_last( per ); // initialize to last period's info
		world.calc( per ); // call to calculate supply and demand
		marketplace.solve( per ); // solution uses Bisect and NR routine to clear markets
		world.updateSummary( per ); // call to update summaries for reporting
		world.sumpop( per ); // call to calculate global population
		world.emiss_ind( per ); // call to calculate global emissions
		world.sumrsc( per ); // call to calculate global depletable resources
		
		// Write out the results for debugging.
		world.toDebugXML( per, xmlDebugStream );
	}
	
	toDebugXMLClose( per, xmlDebugStream ); // Close the xml debugging tag.
	
	// calling fortran subroutine climat/magicc
	world.emiss_all(); // read in all ghg gases except for CO2
	// climat_data(); // writes the input text file
	gasfile.close(); // close input file for climat
#ifdef WIN32
	cout << endl << "Calling CLIMAT() "<< endl;
    //    CLIMAT();
	cout << "Finished with CLIMAT()" << endl;
#endif
	
	xmlDebugStream.close();
}

//! Function which creates an XML compliant date time string.

/*! 
* This function takes as an argument a time_t object and returns a string containing the date and time in the following format:
* yyyy-mm-dd-Thh:mm-GMTOFFSET
* ie: 2003-01-11T09:30:47-05:00
* \param time time_t to convert to XML string form.
* \return string The time converted to XML date string format.
* \todo Find a better location for this function. 
* \bug GMT offset does not work properly.
*/

string Scenario::XMLCreateDate( const time_t& time ) {
	stringstream buffer;
	string retString;
	struct tm* timeInfo;
	struct tm* umtTimeInfo;
	
	timeInfo = localtime( &time );
	umtTimeInfo = gmtime( &time );
	
	// Create the string
	buffer << ( timeInfo->tm_year + 1900 ); // Set the year
	buffer << "-";
	buffer << timeInfo->tm_mday; // Set the day
	buffer << "-";
	buffer << ( timeInfo->tm_mon + 1 ); // Month's in ctime range from 0-11
	buffer << "T";
	buffer << timeInfo->tm_hour;
	buffer << ":";
	buffer << timeInfo->tm_min;
	buffer << ":";
	buffer << timeInfo->tm_sec;
	buffer << "-";
	
	int umtDiff = timeInfo->tm_hour - umtTimeInfo->tm_hour;
	if( umtDiff < 10 ) {
		buffer << "0";
	}
	buffer << umtDiff;
	buffer << ":00";
	// Completed creating the string;
	buffer >> retString;
	
	return retString;
}

