/*
 */
package ModelInterface.ConfigurationEditor.guihelpers;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import org.w3c.dom.Node;

import ModelInterface.ConfigurationEditor.utils.DOMUtils;

/**
 * A class which wraps a DOM node for a JTree and replaces the toString function
 * with one which returns the element name and the value of the name attribute.
 * This class uses a proxy method so that all function calls other than toString
 * automatically are forwarded to the underlying node.
 * 
 * @author Josh Lurz
 * 
 */
public class TreeNodeWrapper implements InvocationHandler {

	/**
	 * Create an instance of this wrapper class with a node to wrap.
	 * 
	 * @param aNode
	 *            The node to wrap in this proxy class.
	 * @return An instance of the invocation handler.
	 */
	public static Object createProxy(final Node aNode) {
		return Proxy.newProxyInstance(aNode.getClass().getClassLoader(), aNode
				.getClass().getInterfaces(), new TreeNodeWrapper(aNode));
	}

	/**
	 * The internal node which this class wraps.
	 */
	private transient final Node mInternalNode;

	/**
	 * Private constructor which sets the internal node to the one passed in.
	 * 
	 * @param aNodeToWrap
	 *            The node to forward all function calls to except toString.
	 */
	private TreeNodeWrapper(Node aNodeToWrap) {
        super();
		mInternalNode = aNodeToWrap;
	}

	/**
	 * Method called when a function is invoked on the object. Checks if the
	 * function is the toString function and replaces it with a function that
	 * returns the value of the name attribute. Otherwise the call is forwarded
	 * to the internal node.
	 * 
	 * @param aProxy
	 *            The object on which the method is being invoked.
	 * @param aMethod
	 *            The method being invoked.
	 * @param aArgs
	 *            The arguments of the method being invoked.
	 * @return The return value of the requested method.
	 * @throws Throwable
	 *             Exception generated by the method.
	 */
	public Object invoke(final Object aProxy, final Method aMethod, final Object[] aArgs)
			throws Throwable {
		// Special case the toString method to return the element name plus the
		// value of the name
		// child.
		if (aMethod.getName().equals("toString")) { //$NON-NLS-1$
			// Return a string that looks like <element name="name">value</element>
			// for child node or <element> for parent nodes.
            final String nameAttr = DOMUtils.getNameAttrValue(mInternalNode);
			
			final StringBuilder displayString = new StringBuilder();
			displayString.append("<");
			displayString.append(mInternalNode.getNodeName());
			// Don't print empty name attributes.
			if(nameAttr != null && !nameAttr.equals("")){
				displayString.append(" name=\"").append(nameAttr).append("\"");
			}
			displayString.append(">");
			
			// Now append the value if this is a child node. 
			if(DOMUtils.getNumberOfElementChildren(mInternalNode) <= 0 ){
				displayString.append(mInternalNode.getTextContent());
			
				// Append the closing tag for child nodes only.
				displayString.append("<").append(mInternalNode.getNodeName()).append(">");
			}
			// Return the entire string.
			return displayString.toString();
		}
		if (aMethod.getName().equals("equals")) {
			return aProxy == aArgs[0] ? Boolean.TRUE : Boolean.FALSE;
		}
		if (aMethod.getName().equals("hashCode")) {
			return new Integer(System.identityHashCode(aProxy));
		}
		// Dispatch all methods other than toString to the internal node object.
		Object result = null;
		try {
			result = aMethod.invoke(mInternalNode, aArgs);
		} catch (InvocationTargetException e) {
			throw e.getCause();
		}
		return result;
	}
}
