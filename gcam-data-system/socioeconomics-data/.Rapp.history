L111.ag_resbio_R_C <- translate_to_full_table( L111.ag_resbio_R_C,#
      R, unique( iso_GCAM_regID[[R]]),#
      C, unique( L111.ag_resbio_R_C[[C]] ),#
      datacols = resbio_params )#
# -----------------------------------------------------------------------------#
# 3. Output#
#Add comments for each table#
comments.L111.ag_resbio_R_C <- c( "Weighted average residue biomass parameters by GCAM region / commodity","Units: varied" )#
#write tables as CSV files#
writedata( L111.ag_resbio_R_C, domain="AGLU_LEVEL1_DATA",fn="L111.ag_resbio_R_C", comments=comments.L111.ag_resbio_R_C )#
# Every script should finish with this line#
logstop()
source("../aglu-processing-code/level1/L112.ag_prodchange_R_C_Y.R")
L112.ag_YieldRatio_R_C_Ysy_AEZ[1:30,]
GCAM_region_names
source("../aglu-processing-code/level1/L113.bio_Yield_R_AEZ.R")
L113.ag_bioYield_GJm2_R_AEZ_ref
L113.ag_bioYield_GJm2_R_AEZ_ref <- L113.ag_bioYieldIndex_R_AEZ#
L113.ag_bioYield_GJm2_R_AEZ_ref[ AEZs ] <-#
      L113.ag_bioYieldIndex_R_AEZ[ AEZs ] * EPIC_bio_Yield$MEAN_SD_kgm2[ EPIC_bio_Yield$AEZ == Index_AEZ ]#
L113.ag_bioYield_GJm2_R_AEZ_ref[ AEZs_arid ] <-#
      L113.ag_bioYieldIndex_R_AEZ[ AEZs_arid ] * EPIC_bio_Yield$MEAN_kgm2[ EPIC_bio_Yield$AEZ == Index_AEZ ]#
L113.ag_bioYield_GJm2_R_AEZ_ref[ is.na( L113.ag_bioYield_GJm2_R_AEZ_ref ) ] <- 0
L113.ag_bioYield_GJm2_R_AEZ_ref
L113.ag_bioYield_GJm2_R_AEZ_hi <- L113.ag_bioYieldIndex_R_AEZ#
L113.ag_bioYield_GJm2_R_AEZ_hi[ AEZs ] <-#
      L113.ag_bioYieldIndex_R_AEZ[ AEZs ] * EPIC_bio_Yield$MEAN_mult_kgm2[ EPIC_bio_Yield$AEZ == Index_AEZ ]
L113.ag_bioYield_GJm2_R_AEZ_hi
source("../aglu-processing-code/level1/L113.bio_Yield_R_AEZ.R")
source("../aglu-processing-code/level1/L114.ag_prodchange_scenarios.R")
subset(L114.ag_YieldRatio_R_C_Y_AEZ_ref, GCAM_region_ID==30)
L114.ag_YieldRatio_R_C_Y_AEZ_ref[1:30,]
L114.bio_YieldRatio_R_AEZ_Y_ref
source(paste(AGLUPROC_DIR,"/../_common/headers/GCAM_header.R",sep=""))#
source(paste(AGLUPROC_DIR,"/../_common/headers/AGLU_header.R",sep=""))#
logstart( "L120.LC_GIS_R_LTgis_Yh_AEZ.R" )#
adddep(paste(AGLUPROC_DIR,"/../_common/headers/GCAM_header.R",sep=""))#
adddep(paste(AGLUPROC_DIR,"/../_common/headers/AGLU_header.R",sep=""))#
printlog( "Land cover by region / GIS land types / historical year / AEZ" )#
# -----------------------------------------------------------------------------#
# 1. Read data from GIS mapping#
sourcedata( "COMMON_ASSUMPTIONS", "A_common_data", extension = ".R" )#
sourcedata( "COMMON_ASSUMPTIONS", "unit_conversions", extension = ".R" )#
sourcedata( "AGLU_ASSUMPTIONS", "A_aglu_data", extension = ".R" )#
iso_GCAM_regID <- readdata( "COMMON_MAPPINGS","iso_GCAM_regID" )#
GIS_ctry_AEZ <- readdata( "AGLU_MAPPINGS","GIS_ctry_AEZ" )#
GIS_land_types <- readdata( "AGLU_MAPPINGS","GIS_land_types" )#
SAGE_LT <- readdata( "AGLU_MAPPINGS","SAGE_LT" )#
Sage_Hyde15_Area <- readdata( "AGLU_GIS_DATA", "Sage_Hyde15_Area" )#
# -----------------------------------------------------------------------------#
# 2. Perform computations#
#Add vectors for GCAM region ID and AEZ#
Sage_Hyde15_Area$iso <- GIS_ctry_AEZ$iso[ match( Sage_Hyde15_Area$AEZ_ID, GIS_ctry_AEZ$AEZ_ID ) ]#
Sage_Hyde15_Area$AEZ <- GIS_ctry_AEZ$AEZ[ match( Sage_Hyde15_Area$AEZ_ID, GIS_ctry_AEZ$AEZ_ID ) ]#
Sage_Hyde15_Area$GCAM_region_ID <- iso_GCAM_regID$GCAM_region_ID[ match( Sage_Hyde15_Area$iso, iso_GCAM_regID$iso ) ]#
#Add vectors for land type ( SAGE, HYDE, and WDPA )#
printlog( "Mapping in land types from different GIS databases" )#
Sage_Hyde15_Area[ c( "LT_SAGE", "LT_HYDE", "LT_WDPA" ) ] <- GIS_land_types[#
      match( Sage_Hyde15_Area$Category, GIS_land_types$Category ),#
      c( "LT_SAGE", "LT_HYDE", "LT_WDPA" ) ]#
Sage_Hyde15_Area$LT_SAGE_5 <- SAGE_LT$Land_Type[ match( Sage_Hyde15_Area$LT_SAGE, SAGE_LT$LT_SAGE ) ]#
#Drop all rows with missing values ( bodies of water )#
printlog( "Dropping inland water" )#
Sage_Hyde15_Area <- na.omit( Sage_Hyde15_Area )#
#Reset WDPA classification to "Non-protected" where HYDE classification is cropland, pasture, or urban land#
Sage_Hyde15_Area$LT_WDPA[ Sage_Hyde15_Area$LT_HYDE!="Unmanaged" ] <- "Non-protected"#
#These multi-tiered classifications will be used for C contents, but for all land cover processing, collapse into GCAM land types#
printlog ( "Collapsing multi-tiered GIS land types into a single vector of aggregate land types" )#
Sage_Hyde15_Area$Land_Type <- Sage_Hyde15_Area$LT_SAGE_5#
#Need to add levels to new variable Land_Type#
#NOTE: To include protected lands: Add a category called "Protected" to the list below#
Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_HYDE=="Cropland" ] <- "Cropland"#
Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_HYDE=="Pasture" ] <- "Pasture"#
Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_HYDE=="Urbanland" ] <- "UrbanLand"    #This is the only land type whose "land" is capitalized here#
#NOTE: To include protected lands, uncomment the line below#
#Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_WDPA=="Protected" ] <- "Protected"#
#Add vector for area in thousand square kilometers (bm2)#
Sage_Hyde15_Area$Area_bm2 <- Sage_Hyde15_Area$Area.km2. * conv_km2_bm2#
#LAND COVER FOR LAND ALLOCATION#
#Aggregate into GCAM regions and land types. This table is incomplete (missing non-existent combinations), indicated by LCi#
printlog( "Part 1: Land cover by GCAM land category in all model history/base years" )#
printlog( "Collapsing land cover into GCAM regions and aggregate land types" )#
names( Sage_Hyde15_Area )[ names( Sage_Hyde15_Area ) == "Year" ] <- Y#
L120.LCi_bm2_R_LT_year_AEZ <- aggregate( Sage_Hyde15_Area[ "Area_bm2" ], by=as.list( Sage_Hyde15_Area[ R_LT_Y_AEZ ] ), sum )#
#Cast by year and interpolate to include all desired years#
L120.LCi_bm2_R_LT_year_AEZ$Xyear <- paste( "X", L120.LCi_bm2_R_LT_year_AEZ$year, sep = "" )#
L120.LCi_bm2_R_LT_year_AEZ.cast <- cast( L120.LCi_bm2_R_LT_year_AEZ, GCAM_region_ID + Land_Type + AEZ ~ Xyear, value = "Area_bm2" )#
#
###TEMPORARY STEP: SET 2010 EQUAL TO 2005 IN ABSENCE OF ANY REAL DATA FOR 2010#
L120.LCi_bm2_R_LT_year_AEZ.cast$X2010 <- L120.LCi_bm2_R_LT_year_AEZ.cast$X2005#
L120.LCi_bm2_R_LT_allyear_AEZ.cast <- gcam_interp( L120.LCi_bm2_R_LT_year_AEZ.cast, land_cover_years )#
#
#Reset to a data frame, melt, and drop the "X" prefix from the year vector#
L120.LCi_bm2_R_LT_allyear_AEZ.cast <- data.frame( L120.LCi_bm2_R_LT_allyear_AEZ.cast[ R_LT_AEZ ], L120.LCi_bm2_R_LT_allyear_AEZ.cast[ X_land_cover_years ] )#
#
#Create "complete" table with all possible combinations of regions, land types, AEZs, and years#
printlog( "Expanding table to include all possible combinations of region, land type, year, and AEZ" )#
L120.LC_bm2_R_LT_Yh_AEZ <- translate_to_full_table( L120.LCi_bm2_R_LT_allyear_AEZ.cast,#
      var1 = R, var1_values = sort( unique( iso_GCAM_regID$GCAM_region_ID ) ),#
      var2 = LT, var2_values = unique( L120.LCi_bm2_R_LT_year_AEZ$Land_Type ),#
      var3 = AEZ, var3_values = AEZs,#
      datacols = X_land_cover_years )#
#
#Subset the land types that are not further modified, and write them out#
L120.LC_bm2_R_UrbanLand_Yh_AEZ <- L120.LC_bm2_R_LT_Yh_AEZ[ L120.LC_bm2_R_LT_Yh_AEZ[[LT]] =="UrbanLand", ]#
L120.LC_bm2_R_Tundra_Yh_AEZ <- L120.LC_bm2_R_LT_Yh_AEZ[ L120.LC_bm2_R_LT_Yh_AEZ[[LT]] =="Tundra", ]#
L120.LC_bm2_R_RckIceDsrt_Yh_AEZ <- L120.LC_bm2_R_LT_Yh_AEZ[ L120.LC_bm2_R_LT_Yh_AEZ[[LT]] =="RockIceDesert", ]#
#NOTE: If protected lands are included, uncomment the text below#
#LC_bm2_R_Protected_Yh_AEZ <- L120.LC_bm2_R_LT_Yh_AEZ[ L120.LC_bm2_R_LT_Yh_AEZ[[LT]] =="Protected", ]#
#LAND COVER FOR CARBON CONTENT CALCULATION#
printlog ( "Part 2: Land cover by Sage14 category for carbon content calculation" )#
printlog ( "Collapsing land cover into GCAM regions and SAGE 14 land types" )#
Sage_Hyde15_Area_by <- subset( Sage_Hyde15_Area, year == max( year ) )#
L120.LCi_bm2_R_LTsage_AEZ <- aggregate( Sage_Hyde15_Area_by[ "Area_bm2" ],#
      by=as.list( Sage_Hyde15_Area_by[ c( R, "LT_SAGE", AEZ ) ] ), sum )#
L120.LCi_bm2_R_LTsage_AEZ.cast <- cast( L120.LCi_bm2_R_LTsage_AEZ, GCAM_region_ID + LT_SAGE ~ AEZ, value = "Area_bm2" )#
L120.LCi_bm2_R_LTsage_AEZ.cast[ is.na( L120.LCi_bm2_R_LTsage_AEZ.cast ) ] <- 0#
#Create "complete" table with all possible combinations of regions, land types, AEZs, and years#
printlog( "Expanding table to include all possible combinations of region, land type, and AEZ" )#
L120.LC_bm2_R_LTsage_AEZ <- translate_to_full_table( L120.LCi_bm2_R_LTsage_AEZ.cast,#
      var1 = R, var1_values = sort( unique( iso_GCAM_regID$GCAM_region_ID ) ),#
      var2 = "LT_SAGE", var2_values = unique( L120.LCi_bm2_R_LTsage_AEZ.cast$LT_SAGE ),#
      datacols = AEZs  )
Sage_Hyde15_Area$iso <- GIS_ctry_AEZ$iso[ match( Sage_Hyde15_Area$AEZ_ID, GIS_ctry_AEZ$AEZ_ID ) ]#
Sage_Hyde15_Area$AEZ <- GIS_ctry_AEZ$AEZ[ match( Sage_Hyde15_Area$AEZ_ID, GIS_ctry_AEZ$AEZ_ID ) ]#
Sage_Hyde15_Area$GCAM_region_ID <- iso_GCAM_regID$GCAM_region_ID[ match( Sage_Hyde15_Area$iso, iso_GCAM_regID$iso ) ]#
#Add vectors for land type ( SAGE, HYDE, and WDPA )#
printlog( "Mapping in land types from different GIS databases" )#
Sage_Hyde15_Area[ c( "LT_SAGE", "LT_HYDE", "LT_WDPA" ) ] <- GIS_land_types[#
      match( Sage_Hyde15_Area$Category, GIS_land_types$Category ),#
      c( "LT_SAGE", "LT_HYDE", "LT_WDPA" ) ]#
Sage_Hyde15_Area$LT_SAGE_5 <- SAGE_LT$Land_Type[ match( Sage_Hyde15_Area$LT_SAGE, SAGE_LT$LT_SAGE ) ]#
#Drop all rows with missing values ( bodies of water )#
printlog( "Dropping inland water" )#
Sage_Hyde15_Area <- na.omit( Sage_Hyde15_Area )#
#Reset WDPA classification to "Non-protected" where HYDE classification is cropland, pasture, or urban land#
Sage_Hyde15_Area$LT_WDPA[ Sage_Hyde15_Area$LT_HYDE!="Unmanaged" ] <- "Non-protected"#
#These multi-tiered classifications will be used for C contents, but for all land cover processing, collapse into GCAM land types#
printlog ( "Collapsing multi-tiered GIS land types into a single vector of aggregate land types" )#
Sage_Hyde15_Area$Land_Type <- Sage_Hyde15_Area$LT_SAGE_5#
#Need to add levels to new variable Land_Type#
#NOTE: To include protected lands: Add a category called "Protected" to the list below#
Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_HYDE=="Cropland" ] <- "Cropland"#
Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_HYDE=="Pasture" ] <- "Pasture"#
Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_HYDE=="Urbanland" ] <- "UrbanLand"    #This is the only land type whose "land" is capitalized here#
#NOTE: To include protected lands, uncomment the line below#
#Sage_Hyde15_Area$Land_Type[ Sage_Hyde15_Area$LT_WDPA=="Protected" ] <- "Protected"
Sage_Hyde15_Area$Area_bm2 <- Sage_Hyde15_Area$Area.km2. * conv_km2_bm2#
#LAND COVER FOR LAND ALLOCATION#
#Aggregate into GCAM regions and land types. This table is incomplete (missing non-existent combinations), indicated by LCi#
printlog( "Part 1: Land cover by GCAM land category in all model history/base years" )#
printlog( "Collapsing land cover into GCAM regions and aggregate land types" )#
names( Sage_Hyde15_Area )[ names( Sage_Hyde15_Area ) == "Year" ] <- Y#
L120.LCi_bm2_R_LT_year_AEZ <- aggregate( Sage_Hyde15_Area[ "Area_bm2" ], by=as.list( Sage_Hyde15_Area[ R_LT_Y_AEZ ] ), sum )#
#Cast by year and interpolate to include all desired years#
L120.LCi_bm2_R_LT_year_AEZ$Xyear <- paste( "X", L120.LCi_bm2_R_LT_year_AEZ$year, sep = "" )#
L120.LCi_bm2_R_LT_year_AEZ.cast <- cast( L120.LCi_bm2_R_LT_year_AEZ, GCAM_region_ID + Land_Type + AEZ ~ Xyear, value = "Area_bm2" )
L120.LCi_bm2_R_LT_year_AEZ.cast$X2010 <- L120.LCi_bm2_R_LT_year_AEZ.cast$X2005#
L120.LCi_bm2_R_LT_allyear_AEZ.cast <- gcam_interp( L120.LCi_bm2_R_LT_year_AEZ.cast, land_cover_years )
rm(list=lst())
rm(list=list())
rm(list=ls())
ENERGYPROC_DIR <- "../energy-processing-code/"
getwd()
sourcedata( "COMMON_ASSUMPTIONS", "A_common_data", extension = ".R" )#
sourcedata( "COMMON_ASSUMPTIONS", "unit_conversions", extension = ".R" )#
sourcedata( "ENERGY_ASSUMPTIONS", "A_energy_data", extension = ".R" )#
GCAM_region_names <- readdata( "COMMON_MAPPINGS", "GCAM_region_names" )#
iso_GCAM_regID <- readdata( "COMMON_MAPPINGS", "iso_GCAM_regID" )
source(paste(ENERGYPROC_DIR,"/../_common/headers/GCAM_header.R",sep=""))#
source(paste(ENERGYPROC_DIR,"/../_common/headers/ENERGY_header.R",sep=""))#
logstart( "L144.global_building.R" )#
adddep(paste(ENERGYPROC_DIR,"/../_common/headers/GCAM_header.R",sep=""))#
adddep(paste(ENERGYPROC_DIR,"/../_common/headers/ENERGY_header.R",sep=""))#
printlog( "Global Building Data" )#
# -----------------------------------------------------------------------------#
# 1. Read files#
sourcedata( "COMMON_ASSUMPTIONS", "A_common_data", extension = ".R" )#
sourcedata( "COMMON_ASSUMPTIONS", "unit_conversions", extension = ".R" )#
sourcedata( "ENERGY_ASSUMPTIONS", "A_energy_data", extension = ".R" )#
GCAM_region_names <- readdata( "COMMON_MAPPINGS", "GCAM_region_names" )#
iso_GCAM_regID <- readdata( "COMMON_MAPPINGS", "iso_GCAM_regID" )
GCAM_region_names
A_regions <- readdata( "ENERGY_ASSUMPTIONS", "A_regions" )#
bld_iso_region <- readdata( "ENERGY_MAPPINGS", "bld_iso_region" )#
calibrated_techs_bld_det <- readdata( "ENERGY_MAPPINGS", "calibrated_techs_bld_det" )#
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )#
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )#
A44.USA_TechChange <- readdata( "ENERGY_ASSUMPTIONS", "A44.USA_TechChange" )
L142.in_EJ_R_bld_F_Yh <- readdata( "ENERGY_LEVEL1_DATA", "L142.in_EJ_R_bld_F_Yh" )
source("../energy-processing-code/level1/L142.building.R")
source("../energy-processing-code/level1/L142.building.R")
source("../energy-processing-code/level1/L142.building.R")
logstop()
logstop()
logstart( "L144.global_building.R" )#
adddep(paste(ENERGYPROC_DIR,"/../_common/headers/GCAM_header.R",sep=""))#
adddep(paste(ENERGYPROC_DIR,"/../_common/headers/ENERGY_header.R",sep=""))#
printlog( "Global Building Data" )#
# -----------------------------------------------------------------------------#
# 1. Read files#
sourcedata( "COMMON_ASSUMPTIONS", "A_common_data", extension = ".R" )#
sourcedata( "COMMON_ASSUMPTIONS", "unit_conversions", extension = ".R" )#
sourcedata( "ENERGY_ASSUMPTIONS", "A_energy_data", extension = ".R" )#
GCAM_region_names <- readdata( "COMMON_MAPPINGS", "GCAM_region_names" )#
iso_GCAM_regID <- readdata( "COMMON_MAPPINGS", "iso_GCAM_regID" )#
A_regions <- readdata( "ENERGY_ASSUMPTIONS", "A_regions" )#
bld_iso_region <- readdata( "ENERGY_MAPPINGS", "bld_iso_region" )#
calibrated_techs_bld_det <- readdata( "ENERGY_MAPPINGS", "calibrated_techs_bld_det" )#
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )#
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )#
A44.USA_TechChange <- readdata( "ENERGY_ASSUMPTIONS", "A44.USA_TechChange" )#
L142.in_EJ_R_bld_F_Yh <- readdata( "ENERGY_LEVEL1_DATA", "L142.in_EJ_R_bld_F_Yh" )
dim(L142.in_EJ_R_bld_F_Yh)
L142.in_EJ_R_bld_F_Yh[1:50,1:10]
L144.USA_TechChange <- gcam_interp( A44.USA_TechChange, c( historical_years, future_years ) )#
L144.USA_TechChange <- L144.USA_TechChange[ c( supp, tech, c( X_historical_years, X_future_years ) ) ]#
#Now, make a data table with the timesteps that corresponds to the above data frame#
timesteps <- c( historical_years, future_years )[ 2:length( c( historical_years, future_years ) ) ] -#
  c( historical_years, future_years )[ 1:(length( c( historical_years, future_yearsure_years ) ) - 1 ) ]#
timesteps_rep_techs <- t( data.frame( timesteps ) )[ rep( 1, times = nrow( L144.USA_TechChange ) ), ]#
#Use this table to convert the tech change table into ratios (multipliers) from a base year#
L144.USA_TechMult <- L144.USA_TechChange#
L144.USA_TechMult[ X_historical_years[1] ] <- 1#
for( i in 2:length( c( X_historical_years, X_future_years ) ) ){#
  L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i] <-#
    L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i-1] *#
    ( 1 + L144.USA_TechChange[ c( X_historical_years, X_future_years ) ][ i ] )^#
    timesteps_rep_techs[i-1]#
}
timesteps <- c( historical_years, future_years )[ 2:length( c( historical_years, future_years ) ) ] -#
  c( historical_years, future_years )[ 1:(length( c( historical_years, future_years ) ) - 1 ) ]
timesteps
timesteps_rep_techs <- t( data.frame( timesteps ) )[ rep( 1, times = nrow( L144.USA_TechChange ) ), ]#
#Use this table to convert the tech change table into ratios (multipliers) from a base year#
L144.USA_TechMult <- L144.USA_TechChange#
L144.USA_TechMult[ X_historical_years[1] ] <- 1#
for( i in 2:length( c( X_historical_years, X_future_years ) ) ){#
  L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i] <-#
    L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i-1] *#
    ( 1 + L144.USA_TechChange[ c( X_historical_years, X_future_years ) ][ i ] )^#
    timesteps_rep_techs[i-1]#
}
L144.USA_TechMult
region_GCAM3
region_GCAM3 <- unique(iso_GCAM_regID$region_GCAM3)
region_GCAM3
L144.TechMult_R <- repeat_and_add_vector( L144.USA_TechMult, "region_GCAM3", region_GCAM3 )
L144.TechMult_R[1:30,]
L144.TechMult_R <- L144.TechMult_R[c("region_GCAM3", supp, tech, X_historical_years, X_future_years)]
head(L144.TechMult_R)
A44.shell_eff_mult_RG3
A44.shell_eff_mult_RG3 <- gcam_interp( A44.shell_eff_mult_RG3, c( historical_years, future_years ) )#
A44.shell_eff_mult_RG3 <- A44.shell_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]
head(A44.shell_eff_mult_RG3)
head(A44.shell_eff_mult_RG3)
L144.TechMult_R[1,2]
L144.TechMult_R[1,]
L144.TechMult_R[1:2,]
?grepl
grepl( "shell", L144.TechMult_R$technology )
L144.ShellTechMult_R <- subset( L144.TechMult_R, grepl( "shell", technology ) )
L144.ShellTechMult_R
grep( "shell", L144.TechMult_R$technology )
L144.ShellTechMult_R <- subset( L144.TechMult_R, grep( "shell", technology ) )
L144.ShellTechMult_R <- subset( L144.TechMult_R, grep( "shell", technology ) )
head(L144.ShellTechMult_R)
L144.shell_eff_R_Y <- L144.ShellTechMult_R #
L144.shell_eff_R_Y[ c( X_historical_years, X_future_years ) ] <- L144.ShellTechMult_R[ c( X_historical_years,X_future_years ) ] * #
      A44.shell_eff_mult_RG3[ match( L144.ShellTechMult_R$region_GCAM3, A44.shell_eff_mult_RG3$region_GCAM3 ),#
      c( X_historical_years, X_future_years ) ]
head(L144.shell_eff_R_Y)
A44.shell_eff_mult_RG3
head(A44.tech_eff_mult_RG3)
A44.tech_eff_mult_RG3
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )
A44.tech_eff_mult_RG3
A44.tech_eff_mult_RG3 <- gcam_interp( A44.tech_eff_mult_RG3, c( historical_years, future_years ) )#
A44.tech_eff_mult_RG3 <- A44.tech_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]
?grep
L144.EnduseTechMult_R <- subset( L144.TechMult_R, !grepl( "shell", technology ) )
L144.EnduseTechMult_R
head(L144.EnduseTechMult_R)
L144.EnduseTechMult_R <- subset( L144.TechMult_R, !grepl( "shell", technology ) )#
L144.end_use_eff <- L144.EnduseTechMult_R#
L144.end_use_eff[ c( X_historical_years, X_future_years ) ] <- L144.EnduseTechMult_R[ c( X_historical_years,X_future_years ) ] * #
  A44.tech_eff_mult_RG3[ match( L144.EnduseTechMult_R$region_GCAM3, A44.tech_eff_mult_RG3$region_GCAM3 ),#
  c( X_historical_years, X_future_years ) ]
L144.end_use_eff
L144.EnduseTechMult_R <- subset( L144.TechMult_R, !grepl( "shell", technology ) )#
L144.end_use_eff_Index <- L144.EnduseTechMult_R#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.EnduseTechMult_R[ c( X_historical_years,X_future_years ) ] * #
  A44.tech_eff_mult_RG3[ match( L144.EnduseTechMult_R$region_GCAM3, A44.tech_eff_mult_RG3$region_GCAM3 ),#
  c( X_historical_years, X_future_years ) ]
L144.end_use_eff_Index[1:5]
L144.USA_TechMult <- L144.USA_TechChange#
L144.USA_TechMult[ X_historical_years[1] ] <- 1#
for( i in 2:length( c( X_historical_years, X_future_years ) ) ){#
  L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i] <-#
    L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i-1] *#
    ( 1 + L144.USA_TechChange[ c( X_historical_years, X_future_years ) ][ i ] )^#
    timesteps_rep_techs[i-1]#
}
head(L144.USA_TechMult)
2.62*3.413
L144.USA_TechMult[1:10,]
9*1.22
11.06*0.875
11.06*0.875/3.412
11.06*0.875/3.412/2.63
L144.USA_TechMult[[ base_tech_eff_Index_year ]]
base_tech_eff_Index_year <- "X2000"
L144.USA_TechMult[[ base_tech_eff_Index_year ]]
L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] <- L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] /#
      L144.USA_TechMult[ base_tech_eff_Index_year ]
L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] <- L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] /#
      L144.USA_TechMult[[ base_tech_eff_Index_year ]]
head(L144.USA_TechMult)
repeat table by number of regions #
region_GCAM3 <- unique(iso_GCAM_regID$region_GCAM3)#
#
L144.TechMult_R <- repeat_and_add_vector( L144.USA_TechMult, "region_GCAM3", region_GCAM3 )#
L144.TechMult_R <- L144.TechMult_R[c("region_GCAM3", supp, tech, X_historical_years, X_future_years)]#
#Shell efficiency calc#
#First, subset the technology/year multiplier table so that it includes only shells#
L144.ShellTechMult_R <- subset( L144.TechMult_R, grepl( "shell", technology ) )#
#
#interpolate region specific adjustement factors to historical and future years#
A44.shell_eff_mult_RG3 <- gcam_interp( A44.shell_eff_mult_RG3, c( historical_years, future_years ) )#
A44.shell_eff_mult_RG3 <- A44.shell_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
L144.shell_eff_R_Y <- L144.ShellTechMult_R #
L144.shell_eff_R_Y[ c( X_historical_years, X_future_years ) ] <- L144.ShellTechMult_R[ c( X_historical_years,X_future_years ) ] * #
      A44.shell_eff_mult_RG3[ match( L144.ShellTechMult_R$region_GCAM3, A44.shell_eff_mult_RG3$region_GCAM3 ),#
      c( X_historical_years, X_future_years ) ]#
# 2b. Calculate technology efficiency by region, service, technology, and year#
A44.tech_eff_mult_RG3 <- gcam_interp( A44.tech_eff_mult_RG3, c( historical_years, future_years ) )#
A44.tech_eff_mult_RG3 <- A44.tech_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
#First, subset the technology/year multiplier table so that it includes only energy-consuming techs (no shells)#
L144.EnduseTechMult_R <- subset( L144.TechMult_R, !grepl( "shell", technology ) )#
L144.end_use_eff_Index <- L144.EnduseTechMult_R#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.EnduseTechMult_R[ c( X_historical_years,X_future_years ) ] * #
  A44.tech_eff_mult_RG3[ match( L144.EnduseTechMult_R$region_GCAM3, A44.tech_eff_mult_RG3$region_GCAM3 ),#
  c( X_historical_years, X_future_years ) ]#
#These values are indexed to the USA in the base year. Unlike shells, the end-use technology values read to the model#
# are not just indices, so need to multiply through by assumed base efficiency levels for each technology
head(L144.end_use_eff_Index)
history
vecpaste( L144.end_use_eff_Index[ c( supp, tech ) ) ] )
vecpaste( L144.end_use_eff_Index[ c( supp, tech ) ] )
vecpaste( L144.end_use_eff_Index[ c( supp, tech ) ] )
vecpaste( A44.cost_efficiency[ c( supp, tech ) ] )
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] *#
      A44.cost_efficiency$efficiency[#
          match( vecpaste( L144.end_use_eff_Index[ c( supp, tech ) ] ), vecpaste( A44.cost_efficiency[ c( supp, tech ) ] ) ) ]
head(L144.end_use_eff_Index)
L144.end_use_eff_Index[!complete.cases(L144.end_use_eff_Index),]
calibrated_techs_bld_det <- readdata( "ENERGY_MAPPINGS", "calibrated_techs_bld_det" )#
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )#
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )#
A44.USA_TechChange <- readdata( "ENERGY_ASSUMPTIONS", "A44.USA_TechChange" )#
L142.in_EJ_R_bld_F_Yh <- readdata( "ENERGY_LEVEL1_DATA", "L142.in_EJ_R_bld_F_Yh" )
calibrated_techs_bld_det
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )
A44.cost_efficiency
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )
A44.demand_satiation_mult
head(A44.share_serv_fuel)
head(A44.shell_eff_mult_RG3)
head(A44.tech_eff_mult_RG3)
head(A44.USA_TechChange)
A_regions <- readdata( "ENERGY_ASSUMPTIONS", "A_regions" )#
bld_iso_region <- readdata( "ENERGY_MAPPINGS", "bld_iso_region" )#
calibrated_techs_bld_det <- readdata( "ENERGY_MAPPINGS", "calibrated_techs_bld_det" )#
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )#
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )#
A44.USA_TechChange <- readdata( "ENERGY_ASSUMPTIONS", "A44.USA_TechChange" )#
L142.in_EJ_R_bld_F_Yh <- readdata( "ENERGY_LEVEL1_DATA", "L142.in_EJ_R_bld_F_Yh" )#
# 2a. Calculate shell efficiency by region, and year#
#Write out the tech change table to all desired years, and convert to ratios from a base year#
L144.USA_TechChange <- gcam_interp( A44.USA_TechChange, c( historical_years, future_years ) )#
L144.USA_TechChange <- L144.USA_TechChange[ c( supp, tech, c( X_historical_years, X_future_years ) ) ]#
#Now, make a data table with the timesteps that corresponds to the above data frame#
timesteps <- c( historical_years, future_years )[ 2:length( c( historical_years, future_years ) ) ] -#
  c( historical_years, future_years )[ 1:(length( c( historical_years, future_years ) ) - 1 ) ]#
timesteps_rep_techs <- t( data.frame( timesteps ) )[ rep( 1, times = nrow( L144.USA_TechChange ) ), ]#
#Use this table to convert the tech change table into ratios (multipliers) from a base year#
L144.USA_TechMult <- L144.USA_TechChange#
L144.USA_TechMult[ X_historical_years[1] ] <- 1#
for( i in 2:length( c( X_historical_years, X_future_years ) ) ){#
  L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i] <-#
    L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i-1] *#
    ( 1 + L144.USA_TechChange[ c( X_historical_years, X_future_years ) ][ i ] )^#
    timesteps_rep_techs[i-1]#
}#
#
#These multipliers assume a base year of the first historical year. However most of the efficiencies are based on data from more recent#
# years. This next part adjusts the scale so that the index year is not the first historical year#
base_tech_eff_Index_year <- "X2000"#
L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] <- L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] /#
      L144.USA_TechMult[[ base_tech_eff_Index_year ]]#
#This table can then be repeated by the number of regions, and multiplied by region-specific#
# adjustment factors (interpolated)( need to match on the region)#
#repeat table by number of regions #
region_GCAM3 <- unique(iso_GCAM_regID$region_GCAM3)#
#
L144.TechMult_R <- repeat_and_add_vector( L144.USA_TechMult, "region_GCAM3", region_GCAM3 )#
L144.TechMult_R <- L144.TechMult_R[c("region_GCAM3", supp, tech, X_historical_years, X_future_years)]#
#Shell efficiency calc#
#First, subset the technology/year multiplier table so that it includes only shells#
L144.ShellTechMult_R <- subset( L144.TechMult_R, grepl( "shell", technology ) )#
#
#interpolate region specific adjustement factors to historical and future years#
A44.shell_eff_mult_RG3 <- gcam_interp( A44.shell_eff_mult_RG3, c( historical_years, future_years ) )#
A44.shell_eff_mult_RG3 <- A44.shell_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
L144.shell_eff_R_Y <- L144.ShellTechMult_R #
L144.shell_eff_R_Y[ c( X_historical_years, X_future_years ) ] <- L144.ShellTechMult_R[ c( X_historical_years,X_future_years ) ] * #
      A44.shell_eff_mult_RG3[ match( L144.ShellTechMult_R$region_GCAM3, A44.shell_eff_mult_RG3$region_GCAM3 ),#
      c( X_historical_years, X_future_years ) ]#
# 2b. Calculate technology efficiency by region, service, technology, and year#
A44.tech_eff_mult_RG3 <- gcam_interp( A44.tech_eff_mult_RG3, c( historical_years, future_years ) )#
A44.tech_eff_mult_RG3 <- A44.tech_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
#First, subset the technology/year multiplier table so that it includes only energy-consuming techs (no shells)#
L144.EnduseTechMult_R <- subset( L144.TechMult_R, !grepl( "shell", technology ) )#
L144.end_use_eff_Index <- L144.EnduseTechMult_R#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.EnduseTechMult_R[ c( X_historical_years,X_future_years ) ] * #
  A44.tech_eff_mult_RG3[ match( L144.EnduseTechMult_R$region_GCAM3, A44.tech_eff_mult_RG3$region_GCAM3 ),#
  c( X_historical_years, X_future_years ) ]#
#These values are indexed to the USA in the base year. Unlike shells, the end-use technology values read to the model#
# are not just indices, so need to multiply through by assumed base efficiency levels for each technology#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] *#
      A44.cost_efficiency$efficiency[#
          match( vecpaste( L144.end_use_eff_Index[ c( supp, tech ) ] ), vecpaste( A44.cost_efficiency[ c( supp, tech ) ] ) ) ]
dim(L144.end_use_eff_Index)
head(L144.end_use_eff_Index)
any(is.na(L144.end_use_eff_Index))
L144.end_use_eff_Index[!complete.cases(L144.end_use_eff_Index),]
A_regions <- readdata( "ENERGY_ASSUMPTIONS", "A_regions" )#
bld_iso_region <- readdata( "ENERGY_MAPPINGS", "bld_iso_region" )#
calibrated_techs_bld_det <- readdata( "ENERGY_MAPPINGS", "calibrated_techs_bld_det" )#
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )#
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )#
A44.USA_TechChange <- readdata( "ENERGY_ASSUMPTIONS", "A44.USA_TechChange" )#
L142.in_EJ_R_bld_F_Yh <- readdata( "ENERGY_LEVEL1_DATA", "L142.in_EJ_R_bld_F_Yh" )#
# 2a. Calculate shell efficiency by region, and year#
#Write out the tech change table to all desired years, and convert to ratios from a base year#
L144.USA_TechChange <- gcam_interp( A44.USA_TechChange, c( historical_years, future_years ) )#
L144.USA_TechChange <- L144.USA_TechChange[ c( supp, tech, c( X_historical_years, X_future_years ) ) ]#
#Now, make a data table with the timesteps that corresponds to the above data frame#
timesteps <- c( historical_years, future_years )[ 2:length( c( historical_years, future_years ) ) ] -#
  c( historical_years, future_years )[ 1:(length( c( historical_years, future_years ) ) - 1 ) ]#
timesteps_rep_techs <- t( data.frame( timesteps ) )[ rep( 1, times = nrow( L144.USA_TechChange ) ), ]#
#Use this table to convert the tech change table into ratios (multipliers) from a base year#
L144.USA_TechMult <- L144.USA_TechChange#
L144.USA_TechMult[ X_historical_years[1] ] <- 1#
for( i in 2:length( c( X_historical_years, X_future_years ) ) ){#
  L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i] <-#
    L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i-1] *#
    ( 1 + L144.USA_TechChange[ c( X_historical_years, X_future_years ) ][ i ] )^#
    timesteps_rep_techs[i-1]#
}#
#
#These multipliers assume a base year of the first historical year. However most of the efficiencies are based on data from more recent#
# years. This next part adjusts the scale so that the index year is not the first historical year#
base_tech_eff_Index_year <- "X2000"#
L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] <- L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] /#
      L144.USA_TechMult[[ base_tech_eff_Index_year ]]#
#This table can then be repeated by the number of regions, and multiplied by region-specific#
# adjustment factors (interpolated)( need to match on the region)#
#repeat table by number of regions #
region_GCAM3 <- unique(iso_GCAM_regID$region_GCAM3)#
#
L144.TechMult_R <- repeat_and_add_vector( L144.USA_TechMult, "region_GCAM3", region_GCAM3 )#
L144.TechMult_R <- L144.TechMult_R[c("region_GCAM3", supp, tech, X_historical_years, X_future_years)]#
#Shell efficiency calc#
#First, subset the technology/year multiplier table so that it includes only shells#
L144.ShellTechMult_R <- subset( L144.TechMult_R, grepl( "shell", technology ) )#
#
#interpolate region specific adjustement factors to historical and future years#
A44.shell_eff_mult_RG3 <- gcam_interp( A44.shell_eff_mult_RG3, c( historical_years, future_years ) )#
A44.shell_eff_mult_RG3 <- A44.shell_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
L144.shell_eff_R_Y <- L144.ShellTechMult_R #
L144.shell_eff_R_Y[ c( X_historical_years, X_future_years ) ] <- L144.ShellTechMult_R[ c( X_historical_years,X_future_years ) ] * #
      A44.shell_eff_mult_RG3[ match( L144.ShellTechMult_R$region_GCAM3, A44.shell_eff_mult_RG3$region_GCAM3 ),#
      c( X_historical_years, X_future_years ) ]#
# 2b. Calculate technology efficiency by region, service, technology, and year#
A44.tech_eff_mult_RG3 <- gcam_interp( A44.tech_eff_mult_RG3, c( historical_years, future_years ) )#
A44.tech_eff_mult_RG3 <- A44.tech_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
#First, subset the technology/year multiplier table so that it includes only energy-consuming techs (no shells)#
L144.EnduseTechMult_R <- subset( L144.TechMult_R, !grepl( "shell", technology ) )#
L144.end_use_eff_Index <- L144.EnduseTechMult_R#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.EnduseTechMult_R[ c( X_historical_years,X_future_years ) ] * #
  A44.tech_eff_mult_RG3[ match( L144.EnduseTechMult_R$region_GCAM3, A44.tech_eff_mult_RG3$region_GCAM3 ),#
  c( X_historical_years, X_future_years ) ]#
#These values are indexed to the USA in the base year. Unlike shells, the end-use technology values read to the model#
# are not just indices, so need to multiply through by assumed base efficiency levels for each technology#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] *#
      A44.cost_efficiency$efficiency[#
          match( vecpaste( L144.end_use_eff_Index[ c( supp, tech ) ] ), vecpaste( A44.cost_efficiency[ c( supp, tech ) ] ) ) ]
any(is.na(L144.end_use_eff_Index))
L144.share_fuel <- aggregate( A44.share_serv_fuel[[ "share_TFEbysector" ]], by=as.list( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), sum )#
names( L144.share_fuel )[ names( L144.share_fuel ) == "x" ] <- "fuel_share_of_TFEbysector"#
A44.share_serv_fuel$fuel_share_of_TFEbysector <- L144.share_fuel$fuel_share_of_TFEbysector[#
      match( vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), vecpaste( L144.share_fuel[ c( "region_GCAM3", S_F ) ] ) ) ]#
A44.share_serv_fuel$share_serv_fuel <- A44.share_serv_fuel$share_TFEbysector / A44.share_serv_fuel$fuel_share_of_TFEbysector#
#
#Reset NaNs for regions that do not have any of a given fuel type#
A44.share_serv_fuel[ is.na( A44.share_serv_fuel ) ] <- 0
dim(A44.share_serv_fuel)
A44.share_serv_fuel[1:30,]
calibrated_techs_bld_det
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det, R, GCAM_region_names[[R]] )
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det, R, GCAM_region_names[[R]] )
subset(L144.in_EJ_R_bld_serv_F_Yh, fuel == "gas")
iso_GCAM_regID
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]
head(L144.in_EJ_R_bld_serv_F_Yh)
any(is.na(L144.in_EJ_R_bld_serv_F_Yh))
subset(L144.in_EJ_R_bld_serv_F_Yh, supplysector == "resid heating" & fuel == "gas")
subset(iso_GCAM_regID, GCAM_region_ID==12)
subset(iso_GCAM_regID, GCAM_region_ID==13)
subset(iso_GCAM_regID, GCAM_region_ID==14)
subset(iso_GCAM_regID, GCAM_region_ID==15)
subset(iso_GCAM_regID, GCAM_region_ID==16)
subset(iso_GCAM_regID, GCAM_region_ID==17)
subset(iso_GCAM_regID, GCAM_region_ID==18)
subset(iso_GCAM_regID, GCAM_region_ID==19)
subset(iso_GCAM_regID, GCAM_region_ID==20)
subset(iso_GCAM_regID, GCAM_region_ID==21)
subset(iso_GCAM_regID, GCAM_region_ID==22)
subset(iso_GCAM_regID, GCAM_region_ID==23)
subset(iso_GCAM_regID, GCAM_region_ID==24)
subset(iso_GCAM_regID, GCAM_region_ID==25)
subset(iso_GCAM_regID, GCAM_region_ID==26)
subset(iso_GCAM_regID, GCAM_region_ID==12)
subset(iso_GCAM_regID, GCAM_region_ID==11)
subset(iso_GCAM_regID, GCAM_region_ID==10)
subset(iso_GCAM_regID, GCAM_region_ID==9)
subset(iso_GCAM_regID, GCAM_region_ID==8)
subset(iso_GCAM_regID, GCAM_region_ID==7)
subset(iso_GCAM_regID, GCAM_region_ID==6)
subset(iso_GCAM_regID, GCAM_region_ID==5)
subset(iso_GCAM_regID, GCAM_region_ID==4)
subset(iso_GCAM_regID, GCAM_region_ID==3)
subset(iso_GCAM_regID, GCAM_region_ID==2)
subset(iso_GCAM_regID, GCAM_region_ID==1)
L144.in_EJ_R_bld_serv_F_Yh[1,]
A44.share_serv_fuel[1,]
vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, supp ) ] )
head(A44.share_serv_fuel)
calibrated_techs_bld_det
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )
L144.share_fuel <- aggregate( A44.share_serv_fuel[[ "share_TFEbysector" ]], by=as.list( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), sum )#
names( L144.share_fuel )[ names( L144.share_fuel ) == "x" ] <- "fuel_share_of_TFEbysector"#
A44.share_serv_fuel$fuel_share_of_TFEbysector <- L144.share_fuel$fuel_share_of_TFEbysector[#
      match( vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), vecpaste( L144.share_fuel[ c( "region_GCAM3", S_F ) ] ) ) ]#
A44.share_serv_fuel$share_serv_fuel <- A44.share_serv_fuel$share_TFEbysector / A44.share_serv_fuel$fuel_share_of_TFEbysector#
#
#Reset NaNs for regions that do not have any of a given fuel type#
A44.share_serv_fuel[ is.na( A44.share_serv_fuel ) ] <- 0#
#
#For making the energy consumption table, start with the tech list that will be in each region, and repeat by number of regions#
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det, R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]
head(A44.share_serv_fuel)
vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, supp ) ] )[1:20]
vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] )[1:20]
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, supp ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ) ]
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, supp ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]
any(is.na(L144.in_EJ_R_bld_serv_F_Yh))
L144.in_EJ_R_bld_serv_F_Yh[1:10,]
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )
L144.share_fuel <- aggregate( A44.share_serv_fuel[[ "share_TFEbysector" ]], by=as.list( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), sum )#
names( L144.share_fuel )[ names( L144.share_fuel ) == "x" ] <- "fuel_share_of_TFEbysector"#
A44.share_serv_fuel$fuel_share_of_TFEbysector <- L144.share_fuel$fuel_share_of_TFEbysector[#
      match( vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), vecpaste( L144.share_fuel[ c( "region_GCAM3", S_F ) ] ) ) ]#
A44.share_serv_fuel$share_serv_fuel <- A44.share_serv_fuel$share_TFEbysector / A44.share_serv_fuel$fuel_share_of_TFEbysector#
#
#Reset NaNs for regions that do not have any of a given fuel type#
A44.share_serv_fuel[ is.na( A44.share_serv_fuel ) ] <- 0#
#
#For making the energy consumption table, start with the tech list that will be in each region, and repeat by number of regions#
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det, R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, supp ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]
any(is.na(L144.in_EJ_R_bld_serv_F_Yh))
L144.in_EJ_R_bld_serv_F_Yh[1:20 ]
L144.in_EJ_R_bld_serv_F_Yh[1:20, ]
R_S_F
A_regions <- readdata( "ENERGY_ASSUMPTIONS", "A_regions" )#
bld_iso_region <- readdata( "ENERGY_MAPPINGS", "bld_iso_region" )#
calibrated_techs_bld_det <- readdata( "ENERGY_MAPPINGS", "calibrated_techs_bld_det" )#
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )#
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )#
A44.USA_TechChange <- readdata( "ENERGY_ASSUMPTIONS", "A44.USA_TechChange" )#
L142.in_EJ_R_bld_F_Yh <- readdata( "ENERGY_LEVEL1_DATA", "L142.in_EJ_R_bld_F_Yh" )
So, re-normalize#
L144.share_fuel <- aggregate( A44.share_serv_fuel[[ "share_TFEbysector" ]], by=as.list( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), sum )#
names( L144.share_fuel )[ names( L144.share_fuel ) == "x" ] <- "fuel_share_of_TFEbysector"#
A44.share_serv_fuel$fuel_share_of_TFEbysector <- L144.share_fuel$fuel_share_of_TFEbysector[#
      match( vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), vecpaste( L144.share_fuel[ c( "region_GCAM3", S_F ) ] ) ) ]#
A44.share_serv_fuel$share_serv_fuel <- A44.share_serv_fuel$share_TFEbysector / A44.share_serv_fuel$fuel_share_of_TFEbysector#
#
#Reset NaNs for regions that do not have any of a given fuel type#
A44.share_serv_fuel[ is.na( A44.share_serv_fuel ) ] <- 0
calibrated_techs_bld_det[1:10,]
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )
L144.in_EJ_R_bld_serv_F_Yh[1:10,]
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ) #
      X_historical_years ]
vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ][1:10]
vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] )[1:10]
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]
head(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh[!complete.cases(L144.in_EJ_R_bld_serv_F_Yh),1:15]
source("../energy-processing-code/level1/L142.building.R")
logstop()
source(paste(ENERGYPROC_DIR,"/../_common/headers/GCAM_header.R",sep=""))#
source(paste(ENERGYPROC_DIR,"/../_common/headers/ENERGY_header.R",sep=""))#
logstart( "L144.global_building.R" )#
adddep(paste(ENERGYPROC_DIR,"/../_common/headers/GCAM_header.R",sep=""))#
adddep(paste(ENERGYPROC_DIR,"/../_common/headers/ENERGY_header.R",sep=""))#
printlog( "Global Building Data" )#
# -----------------------------------------------------------------------------#
# 1. Read files#
sourcedata( "COMMON_ASSUMPTIONS", "A_common_data", extension = ".R" )#
sourcedata( "COMMON_ASSUMPTIONS", "unit_conversions", extension = ".R" )#
sourcedata( "ENERGY_ASSUMPTIONS", "A_energy_data", extension = ".R" )#
GCAM_region_names <- readdata( "COMMON_MAPPINGS", "GCAM_region_names" )#
iso_GCAM_regID <- readdata( "COMMON_MAPPINGS", "iso_GCAM_regID" )#
A_regions <- readdata( "ENERGY_ASSUMPTIONS", "A_regions" )#
bld_iso_region <- readdata( "ENERGY_MAPPINGS", "bld_iso_region" )#
calibrated_techs_bld_det <- readdata( "ENERGY_MAPPINGS", "calibrated_techs_bld_det" )#
A44.cost_efficiency <- readdata( "ENERGY_ASSUMPTIONS", "A44.cost_efficiency" )#
A44.demand_satiation_mult <- readdata( "ENERGY_ASSUMPTIONS", "A44.demand_satiation_mult" )#
A44.share_serv_fuel <- readdata( "ENERGY_ASSUMPTIONS", "A44.share_serv_fuel" )#
A44.shell_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.shell_eff_mult_RG3" )#
A44.tech_eff_mult_RG3 <- readdata( "ENERGY_ASSUMPTIONS", "A44.tech_eff_mult_RG3" )#
A44.USA_TechChange <- readdata( "ENERGY_ASSUMPTIONS", "A44.USA_TechChange" )#
L142.in_EJ_R_bld_F_Yh <- readdata( "ENERGY_LEVEL1_DATA", "L142.in_EJ_R_bld_F_Yh" )#
# -----------------------------------------------------------------------------#
# 2. Perform computations#
# 2a. Calculate shell efficiency by region, and year#
#Write out the tech change table to all desired years, and convert to ratios from a base year#
L144.USA_TechChange <- gcam_interp( A44.USA_TechChange, c( historical_years, future_years ) )#
L144.USA_TechChange <- L144.USA_TechChange[ c( supp, tech, c( X_historical_years, X_future_years ) ) ]#
#
#Now, make a data table with the timesteps that corresponds to the above data frame#
timesteps <- c( historical_years, future_years )[ 2:length( c( historical_years, future_years ) ) ] -#
  c( historical_years, future_years )[ 1:(length( c( historical_years, future_years ) ) - 1 ) ]#
#
timesteps_rep_techs <- t( data.frame( timesteps ) )[ rep( 1, times = nrow( L144.USA_TechChange ) ), ]#
#
#Use this table to convert the tech change table into ratios (multipliers) from a base year#
L144.USA_TechMult <- L144.USA_TechChange#
#
L144.USA_TechMult[ X_historical_years[1] ] <- 1#
#
for( i in 2:length( c( X_historical_years, X_future_years ) ) ){#
  L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i] <-#
    L144.USA_TechMult[ c( X_historical_years, X_future_years ) ][i-1] *#
    ( 1 + L144.USA_TechChange[ c( X_historical_years, X_future_years ) ][ i ] )^#
    timesteps_rep_techs[i-1]#
}#
#
#These multipliers assume a base year of the first historical year. However most of the efficiencies are based on data from more recent#
# years. This next part adjusts the scale so that the index year is not the first historical year#
base_tech_eff_Index_year <- "X2000"#
L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] <- L144.USA_TechMult[ c( X_historical_years, X_future_years ) ] /#
      L144.USA_TechMult[[ base_tech_eff_Index_year ]]#
#
#This table can then be repeated by the number of regions, and multiplied by region-specific#
# adjustment factors (interpolated)( need to match on the region)#
#
#repeat table by number of regions #
region_GCAM3 <- unique(iso_GCAM_regID$region_GCAM3)#
#
L144.TechMult_R <- repeat_and_add_vector( L144.USA_TechMult, "region_GCAM3", region_GCAM3 )#
L144.TechMult_R <- L144.TechMult_R[c("region_GCAM3", supp, tech, X_historical_years, X_future_years)]#
#
#Shell efficiency calc#
#First, subset the technology/year multiplier table so that it includes only shells#
L144.ShellTechMult_R <- subset( L144.TechMult_R, grepl( "shell", technology ) )#
#
#interpolate region specific adjustement factors to historical and future years#
A44.shell_eff_mult_RG3 <- gcam_interp( A44.shell_eff_mult_RG3, c( historical_years, future_years ) )#
A44.shell_eff_mult_RG3 <- A44.shell_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
#
L144.shell_eff_R_Y <- L144.ShellTechMult_R #
L144.shell_eff_R_Y[ c( X_historical_years, X_future_years ) ] <- L144.ShellTechMult_R[ c( X_historical_years,X_future_years ) ] * #
      A44.shell_eff_mult_RG3[ match( L144.ShellTechMult_R$region_GCAM3, A44.shell_eff_mult_RG3$region_GCAM3 ),#
      c( X_historical_years, X_future_years ) ]#
# 2b. Calculate technology efficiency by region, service, technology, and year#
#
A44.tech_eff_mult_RG3 <- gcam_interp( A44.tech_eff_mult_RG3, c( historical_years, future_years ) )#
A44.tech_eff_mult_RG3 <- A44.tech_eff_mult_RG3[ c( "region_GCAM3", X_historical_years, X_future_years ) ]#
#
#First, subset the technology/year multiplier table so that it includes only energy-consuming techs (no shells)#
L144.EnduseTechMult_R <- subset( L144.TechMult_R, !grepl( "shell", technology ) )#
L144.end_use_eff_Index <- L144.EnduseTechMult_R#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.EnduseTechMult_R[ c( X_historical_years,X_future_years ) ] * #
  A44.tech_eff_mult_RG3[ match( L144.EnduseTechMult_R$region_GCAM3, A44.tech_eff_mult_RG3$region_GCAM3 ),#
  c( X_historical_years, X_future_years ) ]#
#
#These values are indexed to the USA in the base year. Unlike shells, the end-use technology values read to the model#
# are not just indices, so need to multiply through by assumed base efficiency levels for each technology#
L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] <- L144.end_use_eff_Index[ c( X_historical_years, X_future_years ) ] *#
      A44.cost_efficiency$efficiency[#
          match( vecpaste( L144.end_use_eff_Index[ c( supp, tech ) ] ), vecpaste( A44.cost_efficiency[ c( supp, tech ) ] ) ) ]#
#
# 2c. Calculate costs by service, technology, and year#
# 2d. Calculate energy consumption by region, service, technology, and year#
#Service share data is share of total TFE by sector, not share within each fuel#
#So, re-normalize#
L144.share_fuel <- aggregate( A44.share_serv_fuel[[ "share_TFEbysector" ]], by=as.list( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), sum )#
names( L144.share_fuel )[ names( L144.share_fuel ) == "x" ] <- "fuel_share_of_TFEbysector"#
A44.share_serv_fuel$fuel_share_of_TFEbysector <- L144.share_fuel$fuel_share_of_TFEbysector[#
      match( vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F ) ] ), vecpaste( L144.share_fuel[ c( "region_GCAM3", S_F ) ] ) ) ]#
A44.share_serv_fuel$share_serv_fuel <- A44.share_serv_fuel$share_TFEbysector / A44.share_serv_fuel$fuel_share_of_TFEbysector#
#
#Reset NaNs for regions that do not have any of a given fuel type#
A44.share_serv_fuel[ is.na( A44.share_serv_fuel ) ] <- 0#
#
#For making the energy consumption table, start with the tech list that will be in each region, and repeat by number of regions#
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]
L144.in_EJ_R_bld_serv_F_Yh[!complete.cases(L144.in_EJ_R_bld_serv_F_Yh),1:15]
heat_regions
A_regions
heat_regions <- A_regions[[R]][ A_regions$heat == 1 ]
heat_regions
dim(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, fuel == "heat" & !GCAM_region_ID %in% heat_regions )
dim(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]
noheat_regions <- A_regions[[R]][ A_regions$heat == 0 ]
noheat_regions
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, !fuel == "heat" & GCAM_region_ID %in% noheat_regions )
dim(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh[1:30,]
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]#
#This has a number of combinations that do not apply. Drop the known ones.#
#Heat in regions where this is not modeled as a separate fuel#
noheat_regions <- A_regions[[R]][ A_regions$heat == 0 ]#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, !( fuel == "heat" & GCAM_region_ID %in% noheat_regions ) )
dim(L144.in_EJ_R_bld_serv_F_Yh)
matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]
noheat_regions <- A_regions[[R]][ A_regions$heat == 0 ]#
noheat_regions_heat <- paste( noheat_regions, "heat" )
noheat_regions_heat
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]#
#This has a number of combinations that do not apply. Drop the known ones.#
#Heat in regions where this is not modeled as a separate fuel#
noheat_regions <- A_regions[[R]][ A_regions$heat == 0 ]#
noheat_regions_heat <- paste( noheat_regions, "heat" )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( GCAM_region_ID, fuel ) %in% noheat_regions_heat )
dim(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh[1:10]
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]#
#This has a number of combinations that do not apply. Drop the known ones.#
#Heat in regions where this is not modeled as a separate fuel#
noheat_regions <- A_regions[[R]][ A_regions$heat == 0 ]#
noheat_regions_heat <- paste( noheat_regions, "heat" )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( GCAM_region_ID, fuel ) %!in% noheat_regions_heat )
L144.in_EJ_R_bld_serv_F_Yh[1:10,]
dim(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )
dim(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]#
#This has a number of combinations that do not apply. Drop the known ones.#
#Heat in regions where this is not modeled as a separate fuel#
noheat_regions <- A_regions[[R]][ A_regions$heat == 0 ]#
noheat_regions_heat <- paste( noheat_regions, "heat" )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( GCAM_region_ID, fuel ) %!in% noheat_regions_heat )
noheat_regions_heat <- paste( A_regions[[R]][ A_regions$heat == 0 ], "heat" )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( GCAM_region_ID, fuel ) %!in% noheat_regions_heat )
A_regions
notradbio_regions_tradbio <- paste( A_regions[[R]][ A_regions$tradbio_region == 0 ], "traditional biomass" )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( GCAM_region_ID, fuel ) %!in% notradbio_regions_tradbio )
dim(L144.in_EJ_R_bld_serv_F_Yh)
L144.in_EJ_R_bld_serv_F_Yh[!complete.cases(L144.in_EJ_R_bld_serv_F_Yh),1:10]
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( sector, fuel ) != "bld_comm traditional biomass" )
L144.in_EJ_R_bld_serv_F_Yh[!complete.cases(L144.in_EJ_R_bld_serv_F_Yh),1:10]
L144.in_EJ_R_bld_serv_F_Yh <- repeat_and_add_vector( calibrated_techs_bld_det[ c( S_F, "service" ) ], R, GCAM_region_names[[R]] )#
#
#Match in the name of the region_GCAM3#
#NOTE: This just uses an approximate match between the new regions and the GCAM 3.0 regions, based on the first country alphabetically that is#
# matched between the new and old regions. For new composite regions that are quite different from before, this can cause inconsistent mappings#
L144.in_EJ_R_bld_serv_F_Yh$region_GCAM3 <- iso_GCAM_regID$region_GCAM3[ match( L144.in_EJ_R_bld_serv_F_Yh[[R]], iso_GCAM_regID[[R]] ) ]#
#
#Match in the service shares, and then the energy quantities to be multiplied by the service shares#
L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel <- A44.share_serv_fuel$share_serv_fuel[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ c( "region_GCAM3", S_F, "service" ) ] ),#
             vecpaste( A44.share_serv_fuel[ c( "region_GCAM3", S_F, "service" ) ] ) ) ]#
#
# 2e. Calculate service output by region, service, and year (efficiency times energy consumption, aggregated by service)#
L144.in_EJ_R_bld_serv_F_Yh[ X_historical_years ] <- L144.in_EJ_R_bld_serv_F_Yh$share_serv_fuel * L142.in_EJ_R_bld_F_Yh[#
      match( vecpaste( L144.in_EJ_R_bld_serv_F_Yh[ R_S_F ] ),#
             vecpaste( L142.in_EJ_R_bld_F_Yh[ R_S_F ] ) ),#
      X_historical_years ]#
#This has a number of combinations that do not apply. Drop the known ones.#
#Heat in regions where this is not modeled as a separate fuel#
noheat_regions_heat <- paste( A_regions[[R]][ A_regions$heat == 0 ], "heat" )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( GCAM_region_ID, fuel ) %!in% noheat_regions_heat )#
#
#Traditional biomass in regions where this fuel is not modeled#
notradbio_regions_tradbio <- paste( A_regions[[R]][ A_regions$tradbio_region == 0 ], "traditional biomass" )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( GCAM_region_ID, fuel ) %!in% notradbio_regions_tradbio )#
L144.in_EJ_R_bld_serv_F_Yh <- subset( L144.in_EJ_R_bld_serv_F_Yh, paste( sector, fuel ) != "bld_comm traditional biomass" )
dim(L144.in_EJ_R_bld_serv_F_Yh)
colSums(L144.in_EJ_R_bld_serv_F_Yh[X_historical_years])
colSums(L142.in_EJ_R_bld_F_Yh[X_historical_years])
colSums(L144.in_EJ_R_bld_serv_F_Yh[X_historical_years])/colSums(L142.in_EJ_R_bld_F_Yh[X_historical_years])
tmp<-aggregate(L144.in_EJ_R_bld_serv_F_Yh[X_historical_years],by=as.list(L144.in_EJ_R_bld_serv_F_Yh[R_S_F]),sum)
dim(tmp)
dim(L142.in_EJ_R_bld_F_Yh)
tmp[1:3]==L142.in_EJ_R_bld_F_Yh[1:3]
tmp1 <- tmp
tmp1[X_historical_years] <- tmp[X_historical_years] - L142.in_EJ_R_bld_F_Yh[X_historical_years]
tmp1
tmp1[1:5]
tmp1[abs(tmp1$X1971 > 1e-3),1:5]
tmp1[abs(tmp1$X1971 > 1e-6),1:5]
tmp1[abs(tmp1$X1971 > 1e-13),1:5]
tmp1[abs(tmp1$X1971) > 1e-3,1:5]
tmp1[abs(tmp1$X1971) > 1e-3,]
subset(L144.in_EJ_R_bld_serv_F_Yh, GCAM_region_ID==28)
