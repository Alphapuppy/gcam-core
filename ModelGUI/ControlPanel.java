/*
 * ControlPanel.java
 *
 * Created on May 19, 2003, 11:54 AM
 */

package ModelGUI;

/**
 *
 * @author  Yulia Eyman (yulia@wam.umd.edu)
 *This class provides the Grapical User Interface that interacts
 *with an XML file
 */

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.tree.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.xml.parsers.*;
import org.w3c.dom.NodeList;
import org.jdom.*;
import org.jdom.input.*;
import org.jdom.output.*;

public class ControlPanel extends javax.swing.JFrame {
    
    private JTextField jTFfileName;
    private JPanel browsePanel;
    private JPanel treePanel;
    private JPanel dataPanel;
    private JPanel queryPanel;
    private JTextField valuePane;
    private JSplitPane splitPane;
    private JPanel tableHeaderPanel;
    
    private JButton displayButton;
    private JButton selectNodesButton;
    
    private JTree tree;
    private Document document;
    private java.util.List ansestorNodes;
    private JPopupMenu treeMenu;
    
    private JTable table;
    private int tableFlag;
    private JButton showTableButton;
    private String selection1;
    private String selection2;
    
    private boolean nodeValueChangedFlag;
    
    private boolean showNames;
    private JComboBox listTableBox;
    private JList regionBox;
    
    private Vector queryControls;
    private Vector attributeControls;
    private Vector rootPointers;
    private AdapterNode currRootPointer;
    private boolean tableExistsFlag;
    
    private final JFileChooser fc = new JFileChooser();
    //private PopupListener popupListener;
    
    private static int LIST = 0;
    private static int TABLE = 1;
    private static int DEFAULT_COMPONENT_HEIGHT = 20;
    private static String DEFAULT_SELECTION_STRING = "--chose one--";
    private static String DEFAULT_PLURAL_STRING = "-- all --";
    
    /** Creates new form ControlPanel */
    public ControlPanel() {
        initComponents();
        
        //initialize global flags
        tableExistsFlag = false;
        nodeValueChangedFlag = false;
        
        this.getContentPane().setLayout(new BorderLayout());
        
        jTFfileName = new JTextField();
        jTFfileName.setPreferredSize(new Dimension(300, DEFAULT_COMPONENT_HEIGHT));
        jTFfileName.setMaximumSize(new Dimension(1200, DEFAULT_COMPONENT_HEIGHT));
        
        JButton browseButton = new JButton("Browse...");
        browseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBbrowseActionPerformed(evt);
            }
        });
        
        browsePanel = new JPanel();
        browsePanel.setLayout(new BoxLayout(browsePanel, BoxLayout.X_AXIS));
        browsePanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder(
        "Please select the XML file you wish to view"),BorderFactory.createEmptyBorder(5,5,5,5)));
        
        browsePanel.add(jTFfileName);
        browsePanel.add(Box.createRigidArea(new Dimension(5, 0)));
        browsePanel.add(browseButton);
        
        this.getContentPane().add(browsePanel, BorderLayout.NORTH);
        
        
        displayButton = new JButton("Show XML Tree");
        displayButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                displayButtonActionPerformed(evt);
            }
        });
        
        treePanel = new JPanel();
        treePanel.setLayout(new BoxLayout(treePanel, BoxLayout.Y_AXIS));
        treePanel.setBorder(BorderFactory.createEmptyBorder(0,5,5,5));
        treePanel.add(displayButton);

        this.getContentPane().add(treePanel, BorderLayout.CENTER);

        pack();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                frameResized(evt);
            }
        });

        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });

        pack();
    }//GEN-END:initComponents
    
    private void frameResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_frameResized
        if (evt.getID() == ComponentEvent.COMPONENT_RESIZED) {
           /* if (treePanel != null && treePanel.isShowing()) {
                treePanel.setPreferredSize(treePanel.getSize());
            }
            //appears to be unnecessary
            /*if (dataPanel != null && dataPanel.isShowing()) {
                dataPanel.setPreferredSize(dataPanel.getSize());
            }*/
        }
    }//GEN-LAST:event_frameResized
    
    /*
     *This function allows the user to select all nodes that have the same tag name
     *  (but a different path in the tree) and displays all the values in the panel
     *  to the side of the tree
     */
    private void selectNodesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectNodesButtonActionPerformed
        if (evt.getSource() == selectNodesButton) {
            TreePath[] paths = tree.getSelectionPaths();
            if (paths != null) {
                AdapterNode node;
                
                clearDisplay();
                for (int j = 0; j < paths.length; j++) {
                    //get the tag name of each selected node
                    node = (AdapterNode)paths[j].getLastPathComponent();
                    ansestorNodes = node.getAnsestors();
                    
                    //obtain the axis from user
                    //displayTableChoices();
                }
            }
        }
    }//GEN-LAST:event_selectNodesButtonActionPerformed
    
    /*
     *This function is called when the user enters the name of a file
     *  to be displayed and clicks on the corresponding displayButton
     */
    private void displayButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_displayButtonActionPerformed
        if (evt.getSource() == displayButton) {
            //increase the size of the panel to make room for the JTree
            //this.getContentPane().setPreferredSize(panelSize);
            
            //attempt to read in the XML file into
            //  the private org.w3c.dom.Document document
            boolean success = readXMLFile(jTFfileName.getText());
            if (success) {
                displayTree();
                //selectNodesButton.setEnabled(true);
            }
        }
    }//GEN-LAST:event_displayButtonActionPerformed
    
    
    /*
     *This function is called when the user clicks on the jBbrowse
     *  button, which brings up a file selection dialogue box
     *  The name of the selected file is entered into the editable text box
     */
    private void jBbrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBbrowseActionPerformed
        //Create a file chooser dialogue box
        //final JFileChooser fc = new JFileChooser();
        
        //get the complete name of the selected file
        int returnVal = fc.showOpenDialog(this.getContentPane());
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            jTFfileName.setText(file.getAbsolutePath());
        }
        
    }//GEN-LAST:event_jBbrowseActionPerformed
    
    private void saveAllButtonActionPerformed(java.awt.event.ActionEvent evt) {
        XMLOutputter outputter = new XMLOutputter();
        
        int returnVal = fc.showSaveDialog(this.getContentPane());
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            try {
                outputter.output(document, new FileOutputStream(file));
                nodeValueChangedFlag = false;
            } catch (Exception e) {
                System.err.println(e);
            }
        }
    }
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        if (nodeValueChangedFlag == true) {
            int answer = JOptionPane.showConfirmDialog(this.getContentPane(), "Do you want to save changes to the XML file?");
            if (answer == JOptionPane.YES_OPTION) {
                XMLOutputter outputter = new XMLOutputter();
                
                int returnVal = fc.showSaveDialog(this.getContentPane());
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    File file = fc.getSelectedFile();
                    //jTFfileName.setText(file.getAbsolutePath());
                    try {
                        outputter.output(document, new FileOutputStream("C:/test1.xml"));
                    }
                    catch (Exception e) {
                        System.err.println(e);
                    }
                }
                
            }
        }
        System.exit(0);
    }//GEN-LAST:event_exitForm
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) { }
        
        new ControlPanel().show();
    }
    
    /*
     *readXMLFile takes the full name of an XML file
     *  attempts to read the XML into a DOM parser
     *  Returns boolean indicating whether the read was successful
     */
    public boolean readXMLFile(String fileName) {
        SAXBuilder parser = new SAXBuilder();
        try {
            document = parser.build(new File(fileName));
            return true;
        } catch (Exception e){
            System.out.println("Exception " + e + " in function readXMLFile");
            return false;
        }
    }
    
    /*
     *displayTree creates a visual representation of the DOM created in readXMLFile
     *  The JTree appears in left panel of a split pane,
     *  the text panel on the right allows user to see and edit values of nodes
     */
    public void displayTree() {
        int leftWidth = 350;
        int rightWidth = 350;
        int windowHeight = 500;
        int windowWidth = leftWidth + rightWidth;
        
        tree = new JTree(new JDomToTreeModelAdapter(document));
        //allow multiple nodes to be selected simultaneously
        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        
        //Listen for when the selection changes.
        tree.addTreeSelectionListener(new TreeSelectionListener() {
            public void valueChanged(TreeSelectionEvent e) {
                TreePath[] paths = tree.getSelectionPaths();
                if (paths != null) {
                    clearDisplay();
                    for (int j = 0; j < paths.length; j++) {
                        AdapterNode node = (AdapterNode)paths[j].getLastPathComponent();
                        displayValue(node.getText(), false);
                    }
                }
            }
        });
        
        //listen for right click on the tree
        tree.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
//System.out.println("mousePressed");
                maybeShowPopup(e);
            }
            public void mouseReleased(MouseEvent e) {
//System.out.println("mouseReleased");
                maybeShowPopup(e);
            }
            private void maybeShowPopup(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    treeMenu.show(e.getComponent(), e.getX(), e.getY());
                }
            }
        });
        
        //set the icons of the tree to be blank
        DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer();
        Icon icon = null;
        renderer.setLeafIcon(icon);
        renderer.setClosedIcon(icon);
        renderer.setOpenIcon(icon);
        tree.setCellRenderer(renderer);
        
        // Build left-side view
        JScrollPane treeView = new JScrollPane(tree);
        treeView.setPreferredSize(new Dimension(leftWidth, windowHeight));
        treeView.setMinimumSize(new Dimension(50, 50));
      
        // Build right-side view
        // start with text field to show values of nodes in tree
        valuePane = new JTextField();
        valuePane.setEditable(true);
        valuePane.setPreferredSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
        valuePane.setMinimumSize(new Dimension(30, DEFAULT_COMPONENT_HEIGHT));
        valuePane.setMaximumSize(new Dimension(2000, DEFAULT_COMPONENT_HEIGHT));
        valuePane.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //when user hits enter after updating content of valuePane, the new value will be saved into the tree node
                AdapterNode currNode = (AdapterNode)tree.getLastSelectedPathComponent();
                String newVal = valuePane.getText();
                
                currNode.setText(newVal);
                nodeValueChangedFlag = true;
            }
        });
        
        JPanel tempValPanel = new JPanel();
        tempValPanel.setBorder(BorderFactory.createEmptyBorder(0,0,10,0));
        tempValPanel.setLayout(new BoxLayout(tempValPanel, BoxLayout.X_AXIS));
        tempValPanel.add(new JLabel("Node Value:"));
        tempValPanel.add(Box.createRigidArea(new Dimension(5,0)));
        tempValPanel.add(valuePane);
        
        //More right-side view
        // build panel that'll house query for the table view
        makeQueryPanel(true);
        
        JPanel bigDataPane = new JPanel();
        bigDataPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        bigDataPane.setLayout(new BorderLayout());
        bigDataPane.add(tempValPanel, BorderLayout.NORTH);
        //bidDataPanel.add(Box.createRigidArea(new Dimension(0,10)));
        
        dataPanel = new JPanel();
        dataPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
        dataPanel.setLayout(new BoxLayout(dataPanel, BoxLayout.Y_AXIS));
        dataPanel.add(queryPanel);
        JScrollPane dataView = new JScrollPane(dataPanel);
        //JScrollPane dataView = new JScrollPane
        dataView.setPreferredSize(new Dimension(rightWidth, windowHeight));
        dataView.setMinimumSize(new Dimension(50, 50));
        
        bigDataPane.add(dataView);
        
        //make button that will display the table
        showTableButton = new JButton("Show Query Result");
        showTableButton.setAlignmentX(Box.CENTER_ALIGNMENT);
        showTableButton.setAlignmentY(Box.TOP_ALIGNMENT);
        showTableButton.setMaximumSize(new Dimension(150, DEFAULT_COMPONENT_HEIGHT));
        showTableButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //try {
                showTable();
                /*} catch (Exception ex) {
                    System.out.println("I've failed miserably");
                    System.out.println(ex);
                }*/
            }
        });
        showTableButton.setEnabled(false);
        dataPanel.add(Box.createRigidArea(new Dimension(0,5)));
        dataPanel.add(showTableButton);
        dataPanel.add(Box.createVerticalGlue());
        dataPanel.add(Box.createRigidArea(new Dimension(0,10)));
        
        // Build split-pane view
        splitPane = new JSplitPane( JSplitPane.HORIZONTAL_SPLIT, treeView, bigDataPane);
        splitPane.setContinuousLayout(true);
        splitPane.setDividerLocation(leftWidth);
        splitPane.setPreferredSize(new Dimension(windowWidth + 10, windowHeight+10));
        splitPane.setMinimumSize(new Dimension(windowWidth + 10, windowHeight+10));
        splitPane.setMaximumSize(new Dimension(2000, 1500));
        
        //create the selection button
       /* selectNodesButton = new JButton("Table View");
        selectNodesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectNodesButtonActionPerformed(evt);
            }
        });*/
        
        treeMenu = new JPopupMenu();
        JMenuItem menuItem = new JMenuItem("Add child");
        menuItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                
            }
        });
        treeMenu.add(menuItem);
        menuItem = new JMenuItem("Another popup menu item");
        //menuItem.addActionListener(this);
        treeMenu.add(menuItem);
        
        
        
        JButton saveAllButton = new JButton("Save File");
        saveAllButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveAllButtonActionPerformed(evt);
            }
        });
        
        treePanel.add(Box.createRigidArea(new Dimension(0,5)));
        treePanel.add(splitPane);
        treePanel.add(Box.createRigidArea(new Dimension(0,5)));
        //treePanel.add(selectNodesButton);
        //treePanel.add(Box.createRigidArea(new Dimension(0,5)));
        treePanel.add(saveAllButton);
        pack();
        //treePanel.revalidate();
        //repaint();
    }
    
    private void makeQueryPanel(boolean firstAttempt) {
        if (firstAttempt) {
            firstAttempt = false;
            
            queryPanel = new JPanel();
            queryPanel.setLayout(new BoxLayout(queryPanel, BoxLayout.X_AXIS));
            
            queryPanel.add(new JLabel("View a  "));
            String[] array = {"List ", "Table "};
            listTableBox = new JComboBox(array);
            listTableBox.setMaximumSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
            queryPanel.add(listTableBox);
            
            queryPanel.add(new JLabel("  of  "));
            String[] array2 = {DEFAULT_SELECTION_STRING, "Names", "Numeric Values"};
            JComboBox box = new JComboBox(array2);
            box.setMaximumSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
            box.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    JComboBox temp = (JComboBox)e.getSource();
                    if (temp.getSelectedIndex() == 1) showNames = true;
                    else showNames = false;
                    if (regionBox == null) displayRegionBox();
                }
            });
            queryPanel.add(box);
            
        }
        queryPanel.add(Box.createHorizontalGlue());
    }
    
    private void displayRegionBox() {
        //remove the horizontal glue to display components adjecently
        queryPanel.remove(queryPanel.getComponents().length-1);
        
        //find the first mention of "World", Region nodes will be its children
        currRootPointer = (AdapterNode)tree.getModel().getRoot();
        if (!currRootPointer.hasChild("region")){
            findRoot(currRootPointer, "region");
        }
        rootPointers = new Vector();
        rootPointers.addElement(currRootPointer);
        
        Vector regionNames = new Vector();
        AdapterNode kid;
        java.util.List children = currRootPointer.getChildren();
        Iterator it = children.iterator();
        while (it.hasNext()) {
            kid = (AdapterNode)it.next();
            regionNames.addElement(kid.getAttributeValue("name"));
        }
        
        queryPanel.add(new JLabel("  for region(s)  "));
        regionBox = new JList(regionNames.toArray());
        regionBox.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED),
        BorderFactory.createEmptyBorder(0,3,0,3)));
        
        //add listener - when user chooses region(s), display the next nodes in the hierarchy
        regionBox.addListSelectionListener(new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent e) {
                if (e.getValueIsAdjusting() == false) {
                    showTableButton.setEnabled(true);
                    
                    JList temp = (JList)e.getSource(); //(JList)queryControls.elementAt(0);
                    int index = temp.getMinSelectionIndex();
                    String regionName = temp.getModel().getElementAt(index).toString();
                    
                    //remove any existing query components
                    removeComponents(queryPanel, temp, 0);
                    queryPanel.add(Box.createHorizontalGlue());
                    
                    currRootPointer = (AdapterNode)rootPointers.elementAt(0);
                    rootPointers.addElement(currRootPointer.getChild("region", regionName));
                    addQueryControl(temp, 1);
                }
            }
        });
        
        attributeControls = new Vector();
        queryControls = new Vector();
        queryControls.addElement(regionBox);
        
        queryPanel.add(regionBox);
        
        //put back the horizontal glue to make sure componenets of queryPanel are left justified
        queryPanel.add(Box.createHorizontalGlue());
        
        //pack();
        queryPanel.revalidate();
        repaint();
    }
    
    /*
     * This function removes GUI components that sequentially follow curr components in parent container
     *  Paremeters: parent - the container in the GUI from which elements are to be moved
     *              curr - the component that will be the most recently added component once the function finishes
     *              index - the index in the queryControls array where the pointer to each control is stored
     */
    public void removeComponents(Container parent, Component curr, int index) {
        Component[] comps = parent.getComponents();
        boolean remove = false;
        
        //remove components from the panel
        for (int j = 0; j < comps.length; j++) {
            if (remove) {
                parent.remove(comps[j]);
            }
            if (!remove && curr.equals(comps[j])) {
                remove = true;
            }
        }
        
        repaint();
        
        //remove components from the control arrays (add one because indexes start at 0)
        if (rootPointers != null && rootPointers.size() > index+2) rootPointers.setSize(index+2);
        if (queryControls != null && queryControls.size() > index+1) queryControls.setSize(index+1);
        if (attributeControls != null && attributeControls.size() > index+1) attributeControls.setSize(index+1);
    }
    
    private void addQueryControl(Component predecessor, int index) {
        //get the parent of the nodes whose names will populate the new combo box
        currRootPointer = (AdapterNode)rootPointers.elementAt(index);
        
        //System.out.println("predecessor = " + predecessor.getName() + "|");
        
        //check if combo box already exists, remove all traces of it
        if (queryControls.size() > index) {
            removeComponents(queryPanel, predecessor, index-1);
        } else {    //just elliminate that Horizontal glue that's the last component
            queryPanel.remove(queryPanel.getComponents().length-1);
        }
        
        AdapterNode kid;
        String name;
        Vector names = new Vector();
        names.addElement(DEFAULT_SELECTION_STRING);
        java.util.List children = currRootPointer.getChildren();
        Iterator it = children.iterator();
        while (it.hasNext()) {
            kid = (AdapterNode)it.next();
            name = kid.getName();
            if (names.isEmpty()) names.addElement(name);
            else if (!names.contains(name)) names.addElement(name);
        }
        
        JComboBox comboBox;
        
        //create new entirely component
        comboBox = new JComboBox(names);
        comboBox.setMaximumSize(new Dimension(1000, DEFAULT_COMPONENT_HEIGHT));
        comboBox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JComboBox temp = (JComboBox)e.getSource();
                String name = temp.getSelectedItem().toString();
                int index = queryControls.indexOf(temp);
                
                //check in corresponding node has an attribute name
                currRootPointer = (AdapterNode)rootPointers.elementAt(index);
                if (currRootPointer.hasChildWithAttribute(name, "name")) {
                    addAttributeControl((Component)e.getSource(), name, index);
                } else {    //node does not have "name", only children
                    //System.out.println("entered kid territory");
                    AdapterNode newPointer = currRootPointer.getChild(name, "");
                    if (!newPointer.isLeaf()) { //create new component with the nodes's set of chilren
                        //replace root pointer if it already exists or add new one if it does not
                        if (rootPointers.size() > index+1) {
                            //if the combo box already exists, change the pointer to its contents
                            rootPointers.setElementAt(newPointer, index+1);
                        } else {
                            rootPointers.addElement(newPointer);
                        }
                        addQueryControl((Component)e.getSource(), index+1);
                    }
                }
            }
        });
        
        comboBox.setName(names.toString());
        
        queryControls.addElement(comboBox);
        
        queryPanel.add(new JLabel("  of  "));
        queryPanel.add(comboBox);
        queryPanel.add(Box.createHorizontalGlue());
        
        queryPanel.revalidate();
        repaint();
    }
    
    private void addAttributeControl(Component predecessor, String nodeName, int index){
        //get the parent of the nodes whose names will populate the new combo box
        currRootPointer = (AdapterNode)rootPointers.elementAt(index);
        
        AdapterNode kid;
        String name;
        Vector names = new Vector();
        names.addElement(DEFAULT_SELECTION_STRING);
        names.addElement(DEFAULT_PLURAL_STRING);
        java.util.List children = currRootPointer.getChildren();
        Iterator it = children.iterator();
        while (it.hasNext()) {
            kid = (AdapterNode)it.next();
            if (nodeName.equals(kid.getName())) {
                names.addElement(kid.getAttributeValue("name"));
            }
        }
        
        JComboBox comboBox;
        
        //check if combo box already exists and remove all of its successors if necessary
        if (attributeControls.size() > index || attributeControls.size() >= index) {
            removeComponents(queryPanel, predecessor, index);
        } else {
            //remove the horizontal glue to display components adjecently
            queryPanel.remove(queryPanel.getComponents().length-1);
        }
        
        //create new component
        comboBox = new JComboBox(names);
        comboBox.setMaximumSize(new Dimension(1000, DEFAULT_COMPONENT_HEIGHT));
        comboBox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //get the specific selection of a nodes's name attribute
                JComboBox temp = (JComboBox)e.getSource();
                String attribVal = temp.getSelectedItem().toString();
                int index = attributeControls.indexOf(temp);
                
                //get the name of that node
                temp = (JComboBox)queryControls.elementAt(index);
                String nodeName = temp.getModel().getSelectedItem().toString();
                
                //find node with nodeName and "name" attribute = attribVal
                currRootPointer = (AdapterNode)rootPointers.elementAt(index);
                
                if (attribVal.equals(DEFAULT_PLURAL_STRING)) attribVal = "";
                AdapterNode newPointer = currRootPointer.getChild(nodeName, attribVal);
                if (!newPointer.isLeaf()) {
                    //create new component with the nodes's set of chilren
                    //replace root pointer if it already exists or add new one if it does not
                    if (rootPointers.size() > index+1) {
                        rootPointers.setElementAt(newPointer, index+1);
                    } else {
                        rootPointers.addElement(newPointer);
                    }
                    //removeComponents(queryPanel, (Component)e.getSource(), index);
                    addQueryControl((Component)e.getSource(), index+1);
                }
            }
        });
        
        if (attributeControls.size() < index+1) {
            attributeControls.setSize(index+1);
        }
        attributeControls.setElementAt(comboBox, index);
        
        queryPanel.add(Box.createRigidArea(new Dimension(5,0)));
        queryPanel.add(comboBox);
        queryPanel.add(Box.createHorizontalGlue());
        
        queryPanel.revalidate();
        repaint();
    }
    
    /*
     * recursive function that searches for the first node that has at least one child with the name targetName
     */
    private void findRoot(AdapterNode currRoot, String targetName) {
        if (currRoot.hasChild(targetName)) {
            currRootPointer = currRoot;
            return;
        }
        
        java.util.List children = currRoot.getChildren();
        Iterator it = children.iterator();
        while (it.hasNext()) {
            findRoot((AdapterNode)it.next(), targetName);
        }
    }
    
    /*Prints out the value of a tree node in the adjecent pane
     *Parameters: val=the string to be displayed,
     *  if replace=true, content of the pane is overwritten, otherwise val is apended
     */
    public void displayValue(String val, boolean replace) {
        if (replace == true)
            valuePane.setText(val);
        else {
            String temp = valuePane.getText().trim();
            if (temp.length() != 0) valuePane.setText(temp + '\n' + val);
            else valuePane.setText(val);
        }
    }
    
    public void clearDisplay() {
        valuePane.setText("");
    }
    
    /*
     * Creates the buttons that serve as row lables along the left side of the table
     * Parameters: headings - vector of that are to appear on the buttons
     *                      - the number of buttons created is equal to headings.size()
     *             varName - name of the variable currently being displays in the table's cells
     *                     - is displayed in the corner cell to the left of the column titles and above the row titles
     */
    private JPanel makeLefter(Vector headings, String varName) {
        //create vertical table labels
        JPanel lefterPanel = new JPanel();
        
        Rectangle buttonSize = table.getCellRect(0, 0, true);
        buttonSize = new Rectangle((int)buttonSize.getWidth()+200, (int)buttonSize.getHeight());
        Rectangle blankSize = new Rectangle((int)buttonSize.getWidth(), (int)buttonSize.getHeight()+4);
        lefterPanel.setLayout(new BoxLayout(lefterPanel, BoxLayout.Y_AXIS));
        
        JButton[] lefters = new JButton[headings.size()];
        JButton b = new JButton(varName);
        b.setPreferredSize(blankSize.getSize());
        b.setMinimumSize(blankSize.getSize());
        b.setMaximumSize(blankSize.getSize());
        /*b.addActionListener(new ActionListener() {
            public void actionPerformed (ActionEvent e) {
                //select the entire table
                table.clearSelection();
                //table.changeSelection(0, 0, true, false);
                //table.changeSelection(table.getRowCount()-1, table.getColumnCount()-1, false, true);
                table.getSelectionModel().setSelectionInterval(0, table.getColumnCount()-1);
                //table.grabFocus();
                repaint();
            }
        });*/
        lefterPanel.add(b);
        
        for (int j = 0; j < headings.size(); j++) {
            //create an array of non-editable buttons
            lefters[j] = new JButton(headings.elementAt(j).toString());
            lefters[j].setPreferredSize(buttonSize.getSize());
            lefters[j].setMaximumSize(buttonSize.getSize());
            lefters[j].setName(String.valueOf(j));
            /*lefters[j].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    JButton button = (JButton)e.getSource();
                    int rowIndex = Integer.parseInt(button.getName());
                    int modifiers = e.getModifiers();
                    int numCols = table.getColumnCount();
             
                    //if Control button held, keep previous selection and add new row
                    if ((modifiers & ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK) {
                        table.changeSelection(rowIndex, numCols-1, false, true);
                    } else {
                        table.changeSelection(rowIndex, 0, false, false);
                        table.changeSelection(rowIndex, numCols-1, false, true);
                    }
                    repaint();
                }
            }); */
            lefterPanel.add(lefters[j]);
        }
        
        return lefterPanel;
    }
    
    /*
     * Functioned used to create and make visible the table node values
     */
    public void showTable() {
        Vector values = new Vector();
        Vector header = new Vector();
        Vector lefter = new Vector();
        //String varName = "";
        Vector queue = new Vector();
        int index;
        String nodeName;
        String attribVal = "";
        JComboBox currComboBox;
        java.util.List childNodes;
        
        if (tableExistsFlag) {
            int compCount = dataPanel.getComponentCount();
            //remove the currely showing table, it's the last component
            dataPanel.remove(compCount-1);
            //remove the rigid area seporating table and show table button
            //dataPanel.remove(compCount-2);
        }
        
        //get the name of the last element among the nodes to compaire and know when to stop
        JComboBox lastBox = (JComboBox)queryControls.lastElement();
        String finalNodeName = lastBox.getSelectedItem().toString();
        
        if (listTableBox.getSelectedIndex() == LIST) {
            String regionName;
            Object[] regions = regionBox.getSelectedValues();
            currRootPointer = (AdapterNode)rootPointers.elementAt(0);
            
            //get all regions, place the appropriate nodes in the queue
            //  remove nodes from the begining of the queue and add all appropriate children to the end of the queue
            for (int j = 0; j < regions.length; j++) {
                regionName = regions[j].toString();
                AdapterNode currNode = currRootPointer.getChild("region", regionName);
                currNode.setIndex(1);
                queue.addElement(currNode);
                
                while (!queue.isEmpty()) {
                    currNode = (AdapterNode)queue.remove(0);
                    index = currNode.getIndex();
                    
                    //get the name of the current node
                    currComboBox = (JComboBox)queryControls.elementAt(index);
                    nodeName = currComboBox.getSelectedItem().toString();
                    
                    //get the desired attribute name of the current node
                    attribVal = "";
                    if (!attributeControls.isEmpty() && attributeControls.size() > index && attributeControls.elementAt(index) != null) {
                        //get the "name" attribute if appropriate
                        currComboBox = (JComboBox)attributeControls.elementAt(index);
                        attribVal = currComboBox.getSelectedItem().toString();
                        if (attribVal.equals(DEFAULT_SELECTION_STRING)) attribVal = "";
                    }
                    
                    if(nodeName.equals(finalNodeName)) {
                        String lefterName = regionName + " " + currNode.toString();
                        String prevName;
                        
                        //for nodes directly under period nodes                        
                        int index1, index2; 
                        //Vector newQueue = new Vector();
                        index1 = lefterName.indexOf('<');
                        index2 = lefterName.indexOf('>');
                        if (lefterName.substring(index1+1, index2).equals("period")) {
                            //get a list of all period nodes in that subtree
                            AdapterNode parent = currNode.getParent();
System.out.println("I think period's parent is: " + parent);
                            childNodes = parent.getChildren("period", "");
                            Iterator it = childNodes.iterator();
                            while (it.hasNext()) {
                                //for each period node, get the value of the "final node" under it, 
                                //  remember the period node's year attribute
                                parent = (AdapterNode)it.next();
//System.out.println("I think the period node is: " + parent);
                                currNode = parent.getChild(nodeName, "");
                                //if (showNames) {
                                //    values.addElement(currNode.getAttributeValue("name"));
                                //} else {
                                values.addElement(currNode);
System.out.println("Just added " + currNode);

                                attribVal = parent.getAttributeValue("year");
                                if (attribVal != null) {
                                    if (header.isEmpty()) header.addElement(attribVal);
                                    else if (!header.contains(attribVal)) header.addElement(attribVal);
                                }
                                //}
                                lefterName = regionName + "< >";
                                if (!lefter.isEmpty()) {
                                    prevName = (String)lefter.lastElement();
                                    if (!(prevName.equals(lefterName))) lefter.add(lefterName);
                                } else lefter.add(lefterName);
                            }
                           
                        }
                        else {
                            if (attribVal.equals(DEFAULT_PLURAL_STRING)) attribVal = "";
                            childNodes = currNode.getChildren(nodeName, attribVal);
                            Iterator it = childNodes.iterator();
                            while (it.hasNext()) {
                                currNode = (AdapterNode)it.next();
                                if (showNames) {
                                    values.addElement(currNode.getAttributeValue("name"));
                                } else {
                                    values.addElement(currNode);

                                    attribVal = currNode.getAttributeValue("year");
                                    if (attribVal != null) {
                                        if (header.isEmpty()) header.addElement(attribVal);
                                        else if (!header.contains(attribVal)) header.addElement(attribVal);
                                    }
                                }

                                if (!lefter.isEmpty()) {
                                    prevName = (String)lefter.lastElement();
                                    if (!(prevName.equals(lefterName))) lefter.add(lefterName);
                                } else lefter.add(lefterName);
                            }
                        }
                    } else {
                        if(attribVal.equals(DEFAULT_PLURAL_STRING)) {
                            childNodes = currNode.getChildren(nodeName, "");
                            Iterator it = childNodes.iterator();
                            while (it.hasNext()) {
                                currNode = (AdapterNode)it.next();
                                currNode.setIndex(index+1);
                                queue.addElement(currNode);
                            }
                        } else {
                            currNode = currNode.getChild(nodeName, attribVal);
                            currNode.setIndex(index+1);
                            queue.addElement(currNode);
                        }
                    }
                }
            }

            TableViewModel model = new TableViewModel(values, header, lefter, showNames);
            table = new JTable(model);
            table.setCellSelectionEnabled(true);
            table.setTransferHandler(new TableTransferHandler());
            
            //use panels to place the table appropriately
            JPanel tempPanel = new JPanel();
            tempPanel.setLayout(new BorderLayout());
            tempPanel.add(table.getTableHeader(), BorderLayout.NORTH);
            tempPanel.add(table, BorderLayout.CENTER);
            
            JPanel tempPanel2 = new JPanel();
            tempPanel2.setLayout(new BorderLayout());
            if (!lefter.isEmpty()) {
                //JPanel lefterPanel = makeLefter(lefter, nodeName);
                lefter = model.getTableLefter();
                JPanel lefterPanel = makeLefter(lefter, finalNodeName);
                tempPanel2.add(lefterPanel, BorderLayout.WEST);
            }
            tempPanel2.add(tempPanel, BorderLayout.CENTER);
            
            //dataPanel.add(Box.createRigidArea(new Dimension(0,10)));
            dataPanel.add(tempPanel2);
            
            tableExistsFlag = true;
            
            dataPanel.revalidate();
            repaint();
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
}