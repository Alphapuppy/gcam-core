/*
 * ControlPanel.java
 *
 * Created on May 19, 2003, 11:54 AM
 */

package ModelGUI;

/**
 *
 * @author  Yulia Eyman (yulia@wam.umd.edu)
 *This class provides the Grapical User Interface that interacts
 *  with an XML file
 */

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.tree.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import java.util.zip.*;
import java.awt.*;
import java.awt.event.*;
import javax.xml.parsers.*;
import org.w3c.dom.NodeList;
import org.jdom.*;
import org.jdom.input.*;
import org.jdom.output.*;

public class ControlPanel extends javax.swing.JFrame {
    
    private JTextField jTFfileName;
    private JPanel browsePanel;
    private JPanel treePanel;
    private JPanel dataPanel;
    private JScrollPane dataView;
    private JPanel queryPanel;
    private JTextField valuePane;
    private JSplitPane splitPane;
    private JPanel tableHeaderPanel;
    
    private JDialog addChildDialog;
    private JTextField nameField;
    private JTextField attribField;
    private JTextField valueField;
    private JPanel locationPanel;
    
    private JButton displayButton;
    private JButton selectNodesButton;
    
    private AdapterNode rootTreeNode;
    private MapNode rootMapNode;
    private ModelTime modelTime;
    
    private JTree tree;
    private Document document;
    private java.util.List ansestorNodes;
    private JPopupMenu treeMenu;
    private TreePath selectedPath;
    
    private JTable table;
    private int tableFlag;
    private JButton showTableButton;
    private String selection1;
    private String selection2;
    
    private boolean nodeValueChangedFlag;
    
    private boolean showNames;
    private JComboBox listTableBox;
    private JList regionBox;
    
    private Vector queryControls;
    private Vector attributeControls;
    //private Vector rootPointers;
    private Vector mapPointers;
    //private AdapterNode currRootPointer;
    private boolean tableExistsFlag;
    
    private final JFileChooser fc = new JFileChooser( "." );
    //private PopupListener popupListener;
    
    private static int LIST = 0;
    private static int TABLE = 1;
    private final static int DEFAULT_COMPONENT_HEIGHT = 20;
    protected final static String DEFAULT_SELECTION_STRING = "--chose one--";
    protected final static String DEFAULT_PLURAL_STRING = "-- all --";
    
    /** Creates new form ControlPanel */
    public ControlPanel() {
        initComponents();
        
        //initialize global flags
        tableExistsFlag = false;
        nodeValueChangedFlag = false;
        
        this.getContentPane().setLayout(new BorderLayout());
        
        jTFfileName = new JTextField();
        jTFfileName.setPreferredSize(new Dimension(300, DEFAULT_COMPONENT_HEIGHT));
        jTFfileName.setMaximumSize(new Dimension(1200, DEFAULT_COMPONENT_HEIGHT));
        
        JButton browseButton = new JButton("Browse...");
        browseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBbrowseActionPerformed(evt);
            }
        });
        
        browsePanel = new JPanel();
        browsePanel.setLayout(new BoxLayout(browsePanel, BoxLayout.X_AXIS));
        browsePanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder(
        "Please select the XML file you wish to view"),BorderFactory.createEmptyBorder(5,5,5,5)));
        
        browsePanel.add(jTFfileName);
        browsePanel.add(Box.createRigidArea(new Dimension(5, 0)));
        browsePanel.add(browseButton);
        
        this.getContentPane().add(browsePanel, BorderLayout.NORTH);
        
        
        displayButton = new JButton("Show XML Tree");
        displayButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                displayButtonActionPerformed(evt);
            }
        });
        
        treePanel = new JPanel();
        treePanel.setLayout(new BoxLayout(treePanel, BoxLayout.Y_AXIS));
        treePanel.setBorder(BorderFactory.createEmptyBorder(0,5,5,5));
        treePanel.add(displayButton);
        
        this.getContentPane().add(treePanel, BorderLayout.CENTER);
        
        pack();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                frameResized(evt);
            }
        });

        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });

        pack();
    }//GEN-END:initComponents
    
    private void frameResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_frameResized
        if (evt.getID() == ComponentEvent.COMPONENT_RESIZED) {
           /* if (treePanel != null && treePanel.isShowing()) {
                treePanel.setPreferredSize(treePanel.getSize());
            }
            //appears to be unnecessary
            /*if (dataPanel != null && dataPanel.isShowing()) {
                dataPanel.setPreferredSize(dataPanel.getSize());
            }*/
        }
    }//GEN-LAST:event_frameResized
    
    
    private void selectNodesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectNodesButtonActionPerformed

    }//GEN-LAST:event_selectNodesButtonActionPerformed
    
    /*
     *This function is called when the user enters the name of a file
     *  to be displayed and clicks on the corresponding displayButton
     */
    private void displayButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_displayButtonActionPerformed
        if (evt.getSource() == displayButton) {
            //increase the size of the panel to make room for the JTree
            //this.getContentPane().setPreferredSize(panelSize);
            
            //attempt to read in the XML file into
            //  the private org.w3c.dom.Document document
            boolean success = readXMLFile(jTFfileName.getText());
            if (success) {
                displayTree();
                //selectNodesButton.setEnabled(true);
            }
        }
    }//GEN-LAST:event_displayButtonActionPerformed
    
    
    /*
     *This function is called when the user clicks on the jBbrowse
     *  button, which brings up a file selection dialogue box
     *  The name of the selected file is entered into the editable text box
     */
    private void jBbrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBbrowseActionPerformed
        //Create a file chooser dialogue box
        //final JFileChooser fc = new JFileChooser();
        
        //get the complete name of the selected file
        int returnVal = fc.showOpenDialog(this.getContentPane());
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            jTFfileName.setText(file.getAbsolutePath());
        }
        
    }//GEN-LAST:event_jBbrowseActionPerformed
    
    private void saveAllButtonActionPerformed(java.awt.event.ActionEvent evt) {
        /*XMLOutputter outputter = new XMLOutputter();
        
        int returnVal = fc.showSaveDialog(this.getContentPane());
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            try {
                outputter.output(document, new FileOutputStream(file));
                nodeValueChangedFlag = false;
            } catch (Exception e) {
                System.err.println(e);
            }
        }*/
        
        saveFile();
    }
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        if (nodeValueChangedFlag == true) {
            int answer = JOptionPane.showConfirmDialog(this.getContentPane(), "Do you want to save changes to the XML file?");
            if (answer == JOptionPane.YES_OPTION) {
                XMLOutputter outputter = new XMLOutputter();
                
                int returnVal = fc.showSaveDialog(this.getContentPane());
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    File file = fc.getSelectedFile();
                    //jTFfileName.setText(file.getAbsolutePath());
                    try {
                        outputter.output(document, new FileOutputStream(file));
                        nodeValueChangedFlag = false;
                    } catch (Exception e) {
                        System.err.println(e);
                    }
                }
                
            }
        }
        System.exit(0);
    }//GEN-LAST:event_exitForm
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) { }
        
        new ControlPanel().show();
    }
    
    /*
     *readXMLFile takes the full name of an XML file
     *  attempts to read the XML into a DOM parser
     *  Returns boolean indicating whether the read was successful
     */
    public boolean readXMLFile(String fileName) {
        SAXBuilder parser = new SAXBuilder();
        try {
            document = parser.build(new File(fileName));
            AdapterNode tempRoot = new AdapterNode(document.getRootElement());
            rootMapNode = new MapNode(tempRoot);
            modelTime = new ModelTime(tempRoot);
            return true;
        } catch (Exception e){
            System.out.println("Exception " + e + " in function readXMLFile");
            return false;
        }
    }
    
    /*
     *displayTree creates a visual representation of the DOM created in readXMLFile
     *  The JTree appears in left panel of a split pane,
     *  the text panel on the right allows user to see and edit values of nodes
     */
    public void displayTree() {
        int leftWidth = 350;
        int rightWidth = 350;
        int windowHeight = 500;
        int windowWidth = leftWidth + rightWidth;
        
        tree = new JTree(new JDomToTreeModelAdapter(document));
        //allow multiple nodes to be selected simultaneously
        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        
        //Listen for when the selection changes.
        tree.addTreeSelectionListener(new TreeSelectionListener() {
            public void valueChanged(TreeSelectionEvent e) {
                TreePath[] paths = tree.getSelectionPaths();
                if (paths != null) {
                    clearDisplay();
                    for (int j = 0; j < paths.length; j++) {
                        AdapterNode node = (AdapterNode)paths[j].getLastPathComponent();
                        displayValue(node.getText(), false);
                    }
                }
            }
        });
        
        //listen for right click on the tree
        tree.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
                maybeShowPopup(e);
            }
            public void mouseReleased(MouseEvent e) {
                maybeShowPopup(e);
            }
            private void maybeShowPopup(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    treeMenu.show(e.getComponent(), e.getX(), e.getY());
                    selectedPath = tree.getClosestPathForLocation(e.getX(), e.getY());
                }
            }
        });
        
        //set the icons of the tree to be blank
        DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer();
        Icon icon = null;
        renderer.setLeafIcon(icon);
        renderer.setClosedIcon(icon);
        renderer.setOpenIcon(icon);
        tree.setCellRenderer(renderer);
        
        // Build left-side view
        JScrollPane treeView = new JScrollPane(tree);
        treeView.setPreferredSize(new Dimension(leftWidth, windowHeight));
        treeView.setMinimumSize(new Dimension(50, 50));
        
        // Build right-side view
        // start with text field to show values of nodes in tree
        valuePane = new JTextField();
        valuePane.setEditable(true);
        valuePane.setPreferredSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
        valuePane.setMinimumSize(new Dimension(30, DEFAULT_COMPONENT_HEIGHT));
        valuePane.setMaximumSize(new Dimension(2000, DEFAULT_COMPONENT_HEIGHT));
        valuePane.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //when user hits enter after updating content of valuePane, the new value will be saved into the tree node
                AdapterNode currNode = (AdapterNode)tree.getLastSelectedPathComponent();
                String newVal = valuePane.getText();
                
                currNode.setText(newVal);
                nodeValueChangedFlag = true;
            }
        });
        
        JPanel tempValPanel = new JPanel();
        tempValPanel.setBorder(BorderFactory.createEmptyBorder(0,0,10,0));
        tempValPanel.setLayout(new BoxLayout(tempValPanel, BoxLayout.X_AXIS));
        tempValPanel.add(new JLabel("Node Value:"));
        tempValPanel.add(Box.createRigidArea(new Dimension(5,0)));
        tempValPanel.add(valuePane);
        
        //More right-side view
        // build panel that'll house query for the table view
        makeQueryPanel(true);
        
        JPanel bigDataPane = new JPanel();
        bigDataPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        bigDataPane.setLayout(new BorderLayout());
        bigDataPane.add(tempValPanel, BorderLayout.NORTH);
        //bidDataPanel.add(Box.createRigidArea(new Dimension(0,10)));
        
        dataPanel = new JPanel();
        dataPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
        dataPanel.setLayout(new BoxLayout(dataPanel, BoxLayout.Y_AXIS));
        dataPanel.add(queryPanel);
        dataPanel.addComponentListener(new ComponentListener() {
            public void componentHidden(ComponentEvent e) {}
            public void componentMoved(ComponentEvent e) {} 
            public void componentResized(ComponentEvent e) {
                JScrollBar bar = dataView.getHorizontalScrollBar();
                bar.setValue(bar.getMaximum());                
            }
            public void componentShown(ComponentEvent e) {}

        });
        
        dataView = new JScrollPane(dataPanel);
        dataView.setPreferredSize(new Dimension(rightWidth, windowHeight));
        dataView.setMinimumSize(new Dimension(50, 50));
        dataView.getHorizontalScrollBar().setUnitIncrement(10);
        dataView.getHorizontalScrollBar().setBlockIncrement(50);

        bigDataPane.add(dataView);
        
        //make button that will display the table
        showTableButton = new JButton("Show Query Result");
        showTableButton.setAlignmentX(Box.LEFT_ALIGNMENT);
        showTableButton.setAlignmentY(Box.TOP_ALIGNMENT);
        showTableButton.setMaximumSize(new Dimension(150, DEFAULT_COMPONENT_HEIGHT));
        showTableButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //try {
                showTable();
                /*} catch (Exception ex) {
                    System.out.println("I've failed miserably");
                    System.out.println(ex);
                }*/
            }
        });
        showTableButton.setEnabled(false);
        dataPanel.add(Box.createRigidArea(new Dimension(0,5)));
        dataPanel.add(showTableButton);
        dataPanel.add(Box.createVerticalGlue());
        dataPanel.add(Box.createRigidArea(new Dimension(0,10)));
        
        // Build split-pane view
        splitPane = new JSplitPane( JSplitPane.HORIZONTAL_SPLIT, treeView, bigDataPane);
        splitPane.setContinuousLayout(true);
        splitPane.setDividerLocation(leftWidth);
        splitPane.setPreferredSize(new Dimension(windowWidth + 10, windowHeight+10));
        splitPane.setMinimumSize(new Dimension(windowWidth + 10, windowHeight+10));
        splitPane.setMaximumSize(new Dimension(2000, 1500));
        
        // Build the pop-up menu that's displayed by right-clicking on tree panel
        treeMenu = makePopupMenu();        
        
        JButton saveAllButton = new JButton("Save File");
        saveAllButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveAllButtonActionPerformed(evt);
            }
        });
        
        treePanel.add(Box.createRigidArea(new Dimension(0,5)));
        treePanel.add(splitPane);
        treePanel.add(Box.createRigidArea(new Dimension(0,5)));
        treePanel.add(saveAllButton);
        
        //create the dialog for adding new node children, but leave invisible
        makeAddChildPanel();
        
        pack();
        //treePanel.revalidate();
        //repaint();
    }
    
    private JPopupMenu makePopupMenu() {
        treeMenu = new JPopupMenu();
        JMenuItem menuItem = new JMenuItem("Add Child");
        /*menuItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
            }
        });*/
        menuItem.addMouseListener(new MouseListener() {
            public void mouseReleased(MouseEvent e) {
                tree.setSelectionPath(selectedPath);
                
                showAddChildDialog();
            }
            public void mouseClicked(MouseEvent e) {}
            public void mousePressed(MouseEvent e) {}
            public void mouseEntered(MouseEvent e) {}
            public void mouseExited(MouseEvent e) {}
        });
        treeMenu.add(menuItem);
        
        /*menuItem = new JMenuItem("Print Path");
        menuItem.addMouseListener(new MouseListener() {
            public void mouseReleased(MouseEvent e) {
                tree.setSelectionPath(selectedPath);
         
                System.out.println("Node's path is " + selectedPath);
            }
            public void mouseClicked(MouseEvent e) {}
            public void mousePressed(MouseEvent e) {}
            public void mouseEntered(MouseEvent e) {}
            public void mouseExited(MouseEvent e) {}
        });
        treeMenu.add(menuItem);*/
        
        treeMenu.add(new JSeparator());
        menuItem = new JMenuItem("Show Table and Path");
        menuItem.addMouseListener(new MouseListener() {
            public void mouseReleased(MouseEvent e) {
                tree.setSelectionPath(selectedPath);
                
                makeNewThread();
            }
            public void mouseClicked(MouseEvent e) {}
            public void mousePressed(MouseEvent e) {}
            public void mouseEntered(MouseEvent e) {}
            public void mouseExited(MouseEvent e) {}
        });
        treeMenu.add(menuItem);
        
        treeMenu.add(new JSeparator());
        menuItem = new JMenuItem("Delete Node");
        menuItem.addMouseListener(new MouseListener() {
            public void mouseReleased(MouseEvent e) {
                tree.setSelectionPath(selectedPath);
                
                deleteNode();
            }
            public void mouseClicked(MouseEvent e) {}
            public void mousePressed(MouseEvent e) {}
            public void mouseEntered(MouseEvent e) {}
            public void mouseExited(MouseEvent e) {}
        });
        treeMenu.add(menuItem);
        
        return treeMenu;
    }
    
    private void makeQueryPanel(boolean firstAttempt) {
        if (firstAttempt) {
            firstAttempt = false;
            
            queryPanel = new JPanel();
            queryPanel.setLayout(new BoxLayout(queryPanel, BoxLayout.X_AXIS));
            
            queryPanel.add(new JLabel("View a table of  "));
            /*String[] array = {"List ", "Table "};
            listTableBox = new JComboBox(array);
            listTableBox.setMaximumSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
            queryPanel.add(listTableBox);*/
            
            //queryPanel.add(new JLabel("  of  "));
            String[] array2 = {DEFAULT_SELECTION_STRING, "Names", "Values"};
            JComboBox box = new JComboBox(array2);
            box.setMaximumSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
            box.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    JComboBox temp = (JComboBox)e.getSource();
                    if (temp.getSelectedIndex() == 1) showNames = true;
                    else showNames = false;
                    if (regionBox == null) displayRegionBox();
                }
            });
            queryPanel.add(box);
            
        }
        queryPanel.add(Box.createHorizontalGlue());
    }
    
    private void displayRegionBox() {
        //remove the horizontal glue to display components adjecently
        queryPanel.remove(queryPanel.getComponents().length-1);
        
        //find the first mention of "World", Region nodes will be its children
        rootTreeNode = (AdapterNode)tree.getModel().getRoot();
        if (!rootTreeNode.hasChild("region")){
            findRoot(rootTreeNode, "region");
        }
        //rootPointers = new Vector();
        //rootPointers.addElement(currRootPointer);
        mapPointers = new Vector();
        mapPointers.addElement(rootMapNode.getDescendant("world"));
                
        //get the names of all regions
        MapNode regionNode = rootMapNode.getDescendant("region");
        Vector regionNames = regionNode.getPossibleNames(false);
        mapPointers.addElement(regionNode);
        
        queryPanel.add(new JLabel("  for region(s)  "));
        regionBox = new JList(regionNames.toArray());
        regionBox.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED),
        BorderFactory.createEmptyBorder(0,3,0,3)));
        
        //add listener - when user chooses region(s), display the next nodes in the hierarchy
        regionBox.addListSelectionListener(new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent e) {
                if (e.getValueIsAdjusting() == false) {
                    showTableButton.setEnabled(true);
                    
                    JList temp = (JList)e.getSource();
                    //int index = temp.getMinSelectionIndex();
                    //String regionName = temp.getModel().getElementAt(index).toString();
                    
                    //currRootPointer = (AdapterNode)rootPointers.elementAt(0);
                    //rootPointers.addElement(currRootPointer.getChild("region", regionName));
                    //MapNode mp = (MapNode)mapPointers.elementAt(0);
                    //mapPointers.addElement(mp.getDescendant("region"));
                    
                    //if (rootPointers.size() < 3) addQueryControl(temp, 1);
                    if (mapPointers.size() < 3) addQueryControl(temp, 1);
                }
            }
        });
        
        if (attributeControls == null) attributeControls = new Vector();
        if (queryControls == null) queryControls = new Vector();
        queryControls.addElement(regionBox);
        
        queryPanel.add(regionBox);
        
        //put back the horizontal glue to make sure componenets of queryPanel are left justified
        queryPanel.add(Box.createHorizontalGlue());
        
        queryPanel.revalidate();
        repaint();
    }
    
    /*
     * This function removes GUI components that sequentially follow curr components in parent container
     *  Paremeters: parent - the container in the GUI from which elements are to be moved
     *              curr - the component that will be the most recently added component once the function finishes
     *              index - the index in the queryControls array where the pointer to each control is stored
     */
    public void removeComponents(Container parent, Component curr, int index) {
        Component[] comps = parent.getComponents();
        boolean remove = false;
        
        //remove components from the panel
        for (int j = 0; j < comps.length; j++) {
            if (remove) {
                parent.remove(comps[j]);
            }
            if (!remove && curr.equals(comps[j])) {
                remove = true;
            }
        }
        
        repaint();
        
        //remove components from the control arrays (add one because indexes start at 0)
        //if (rootPointers != null && rootPointers.size() > index+2) rootPointers.setSize(index+2);
        if (mapPointers != null && mapPointers.size() > index+2) mapPointers.setSize(index+2);
        if (queryControls != null && queryControls.size() > index+1) queryControls.setSize(index+1);
        if (attributeControls != null && attributeControls.size() > index+1) attributeControls.setSize(index+1);
    }
    
    private void addQueryControl(Component predecessor, int index) {
        //get the parent of the nodes whose names will populate the new combo box
        //currRootPointer = (AdapterNode)rootPointers.elementAt(index);
        //MapNode currNodePointer = rootMapNode.getDescendant(currRootPointer.getName());
        MapNode mp = (MapNode)mapPointers.elementAt(index);
        boolean hasAttribute = false;
        if (mp.hasPossibleNames()) hasAttribute = true; 
        
        //check if combo box already exists, remove all traces of it
        if ((queryControls.size() > index) || (!hasAttribute && attributeControls.size() > index-1)) {
            removeComponents(queryPanel, predecessor, index-1); 
        } else {    //just elliminate that Horizontal glue that's the last component
            queryPanel.remove(queryPanel.getComponents().length-1);
        }
        
        //if (currNodePointer.isLeaf()) {
        //if node is leaf, no additional boxes need to be added
        if (!mp.hasChildren()) {
            queryPanel.add(Box.createHorizontalGlue());
            queryPanel.revalidate();
            repaint();
            //notifyAll();
        
            return;
        }
        
        //if node does have children
        Vector names = new Vector();
        MapNode kid;
        names.addElement(DEFAULT_SELECTION_STRING);
        Vector children = mp.getChildren();
        Iterator it = children.iterator();
        while (it.hasNext()) {
            kid = (MapNode)it.next();
            names.addElement(kid.getNodeName());
        }
        
        JComboBox comboBox;
        
        //create new entirely component
        comboBox = new JComboBox(names);
        comboBox.setMaximumSize(new Dimension(1000, DEFAULT_COMPONENT_HEIGHT));
        comboBox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JComboBox temp = (JComboBox)e.getSource();
                String name = temp.getSelectedItem().toString();
                int index = queryControls.indexOf(temp);
System.out.println("index = " + index + " of " + queryControls.size());
System.out.println(mapPointers);
                
                //check in corresponding node has an attribute name
                //currRootPointer = (AdapterNode)rootPointers.elementAt(index);
                //if (currRootPointer.hasChildWithAttribute(name, "name")) {
                
                MapNode parent = (MapNode)mapPointers.elementAt(index);
                MapNode mp = parent.getChild(name);
                if (mapPointers.size() > index+1) {
                    mapPointers.setElementAt(mp, index+1);
                } else {
                    mapPointers.addElement(mp);
                }

                if (mp.hasPossibleNames()) {
                    addAttributeControl((Component)e.getSource(), name, index);
                } else {    //node does not have "name", only children
                    //AdapterNode newPointer = currRootPointer.getChild(name, "");
                    MapNode child = mp.getChild(name);

                    // Need to check that the node has children.
                    //if( child != null ) {
                    	//replace root pointer if it already exists or add new one if it does not
                    	/*if (rootPointers.size() > index+1) {
                        	//if the combo box already exists, change the pointer to its contents
                        	rootPointers.setElementAt(newPointer, index+1);
                    	} else {
                        	rootPointers.addElement(newPointer);
                    	}*/
                        /*if (mapPointers.size() > index+1) {
                            mapPointers.setElementAt(mp, index+1);
                        } else {
                            mapPointers.addElement(mp);
                        }*/
                                            
                    	addQueryControl((Component)e.getSource(), index+1);
                    //}
                }
            }
        });
        
        comboBox.setName(names.toString());
        
        queryControls.addElement(comboBox);
        
        queryPanel.add(new JLabel("  of  "));
        queryPanel.add(comboBox);
        queryPanel.add(Box.createHorizontalGlue());
        
        queryPanel.revalidate();
        repaint();
        //notifyAll();
    }
    
    private void addAttributeControl(Component predecessor, String nodeName, int index){
        //get the parent of the nodes whose names will populate the new combo box
        //currRootPointer = (AdapterNode)rootPointers.elementAt(index);
        
        JComboBox tempBox = (JComboBox)queryControls.elementAt(index);
        //MapNode currMapPointer = rootMapNode.getDescendant(tempBox.getSelectedItem().toString());
        MapNode mp = (MapNode)mapPointers.elementAt(index+1);
        
        Vector names = new Vector();
        if (index > 1 && attributeControls.size() > index-1) {
            tempBox = (JComboBox)attributeControls.elementAt(index-1);
            if (tempBox != null) {
                //String parentName = tempBox.getSelectedItem().toString();
                names = mp.getPossibleNames(tempBox.getSelectedItem().toString());
            }
        } else {
            names = mp.getPossibleNames(false);
        }
        
        if (names.size() != 1) names.insertElementAt(DEFAULT_PLURAL_STRING, 0);
        names.insertElementAt(DEFAULT_SELECTION_STRING, 0);
        
        JComboBox comboBox;
        
        //check if combo box already exists and remove all of its successors if necessary
        if (attributeControls.size() > index || attributeControls.size() >= index) {
            removeComponents(queryPanel, predecessor, index);
        } else {
            //remove the horizontal glue to display components adjecently
            queryPanel.remove(queryPanel.getComponents().length-1);
        }
        
        //create new component
        comboBox = new JComboBox(names);
        comboBox.setMaximumSize(new Dimension(1000, DEFAULT_COMPONENT_HEIGHT));
        comboBox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //get the specific selection of a nodes's name attribute
                JComboBox temp = (JComboBox)e.getSource();
                String attribVal = temp.getSelectedItem().toString();
                int index = attributeControls.indexOf(temp);
                
                //get the name of that node
                temp = (JComboBox)queryControls.elementAt(index);
                String nodeName = temp.getModel().getSelectedItem().toString();
                
                //find node with nodeName and "name" attribute = attribVal
                //currRootPointer = (AdapterNode)rootPointers.elementAt(index);
                MapNode mp = (MapNode)mapPointers.elementAt(index);
                MapNode newPointer = mp.getChild(nodeName);
                //if (attribVal.equals(DEFAULT_PLURAL_STRING)) attribVal = "";
                //AdapterNode newPointer = currRootPointer.getChild(nodeName, attribVal);
                if (!newPointer.isLeaf()) {
                    //create new component with the nodes's set of chilren
                    //replace root pointer if it already exists or add new one if it does not
                    /*if (rootPointers.size() > index+1) {
                        rootPointers.setElementAt(newPointer, index+1);
                    } else {
                        rootPointers.addElement(newPointer);
                    }*/
                    //removeComponents(queryPanel, (Component)e.getSource(), index);
                    addQueryControl((Component)e.getSource(), index+1);
                }
                
            }
        });
        
        if (attributeControls.size() < index+1) {
            attributeControls.setSize(index+1);
        }
        attributeControls.setElementAt(comboBox, index);
        
        queryPanel.add(Box.createRigidArea(new Dimension(5,0)));
        queryPanel.add(comboBox);
        queryPanel.add(Box.createHorizontalGlue());
        
        queryPanel.revalidate();
        repaint();
        //notifyAll();
    }
    
    /*
     * recursive function that searches for the first node that has at least one child with the name targetName
     */
    private void findRoot(AdapterNode currRoot, String targetName) {
        if (currRoot.hasChild(targetName)) {
            rootTreeNode = currRoot;
            return;
        }
        
        java.util.List children = currRoot.getChildren();
        Iterator it = children.iterator();
        while (it.hasNext()) {
            findRoot((AdapterNode)it.next(), targetName);
        }
    }
    
    /*Prints out the value of a tree node in the adjecent pane
     *Parameters: val=the string to be displayed,
     *  if replace=true, content of the pane is overwritten, otherwise val is apended
     */
    public void displayValue(String val, boolean replace) {
        if (replace == true)
            valuePane.setText(val);
        else {
            String temp = valuePane.getText().trim();
            if (temp.length() != 0) valuePane.setText(temp + '\n' + val);
            else valuePane.setText(val);
        }
    }
    
    public void clearDisplay() {
        valuePane.setText("");
    }
    
    /*
     * Creates the buttons that serve as row lables along the left side of the table
     * Parameters: headings - vector of that are to appear on the buttons
     *                      - the number of buttons created is equal to headings.size()
     *             varName - name of the variable currently being displays in the table's cells
     *                     - is displayed in the corner cell to the left of the column titles and above the row titles
     */
    private JPanel makeLefter(Vector headings, String varName) {
        //create vertical table labels
        JPanel lefterPanel = new JPanel();
        
        Rectangle buttonSize = table.getCellRect(0, 0, true);
        buttonSize = new Rectangle((int)buttonSize.getWidth()+200, (int)buttonSize.getHeight());
        Rectangle blankSize = new Rectangle((int)buttonSize.getWidth(), (int)buttonSize.getHeight()+4);
        lefterPanel.setLayout(new BoxLayout(lefterPanel, BoxLayout.Y_AXIS));
        
        JButton[] lefters = new JButton[headings.size()];
        JButton b = new JButton(varName);
        b.setPreferredSize(blankSize.getSize());
        b.setMinimumSize(blankSize.getSize());
        b.setMaximumSize(blankSize.getSize());
        /*b.addActionListener(new ActionListener() {
            public void actionPerformed (ActionEvent e) {
                //select the entire table
                table.clearSelection();
                //table.changeSelection(0, 0, true, false);
                //table.changeSelection(table.getRowCount()-1, table.getColumnCount()-1, false, true);
                table.getSelectionModel().setSelectionInterval(0, table.getColumnCount()-1);
                //table.grabFocus();
                repaint();
            }
        });*/
        lefterPanel.add(b);
        
        for (int j = 0; j < headings.size(); j++) {
            //create an array of non-editable buttons
            lefters[j] = new JButton(headings.elementAt(j).toString());
            lefters[j].setPreferredSize(buttonSize.getSize());
            lefters[j].setMaximumSize(buttonSize.getSize());
            lefters[j].setName(String.valueOf(j));
            /*lefters[j].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    JButton button = (JButton)e.getSource();
                    int rowIndex = Integer.parseInt(button.getName());
                    int modifiers = e.getModifiers();
                    int numCols = table.getColumnCount();
             
                    //if Control button held, keep previous selection and add new row
                    if ((modifiers & ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK) {
                        table.changeSelection(rowIndex, numCols-1, false, true);
                    } else {
                        table.changeSelection(rowIndex, 0, false, false);
                        table.changeSelection(rowIndex, numCols-1, false, true);
                    }
                    repaint();
                }
            }); */
            lefterPanel.add(lefters[j]);
        }
        
        return lefterPanel;
    }
    
    /*
     * Functioned used to create and make visible the table node values
     */
    public void showTable() {
        Vector values = new Vector();
        Vector header = new Vector();
        Vector lefter = new Vector();
        //String varName = "";
        Vector queue = new Vector();
        int index;
        String nodeName;
        String attribVal = "";
        JComboBox currComboBox;
        java.util.List childNodes;
        
        if (tableExistsFlag) {
            int compCount = dataPanel.getComponentCount();
            //remove the currely showing table, it's the last component
            dataPanel.remove(compCount-1);
        }
        
        //get the name of the last element among the nodes to compaire and know when to stop
        JComboBox lastBox = (JComboBox)queryControls.lastElement();
        String finalNodeName = lastBox.getSelectedItem().toString();
        
        //if (listTableBox.getSelectedIndex() == LIST) {
        String regionName;
        Object[] regions = regionBox.getSelectedValues();
        //currRootPointer = (AdapterNode)rootPointers.elementAt(0);
        boolean timeInterval = false;
        
        //perform a bredth-first traversal of the tree looking for nodes that fit a path
        //  described by the array of query and attribute controls
        //for each region, place the appropriate nodes in the queue
        //  remove nodes from the begining of the queue and add all appropriate children to the end of the queue
        for (int j = 0; j < regions.length; j++) {
            regionName = regions[j].toString();
            AdapterNode currNode = rootTreeNode.getChild("region", regionName);
            currNode.setIndex(1);
            queue.addElement(currNode);
            
            while (!queue.isEmpty()) {
                currNode = (AdapterNode)queue.remove(0);
                index = currNode.getIndex();
                
                //get the name of the current node
                currComboBox = (JComboBox)queryControls.elementAt(index);
                nodeName = currComboBox.getSelectedItem().toString();
                
                //get the desired attribute name of the current node, if any
                attribVal = "";
                if (!attributeControls.isEmpty() && attributeControls.size() > index
                && attributeControls.elementAt(index) != null) {
                    //get the "name" attribute if appropriate
                    currComboBox = (JComboBox)attributeControls.elementAt(index);
                    attribVal = currComboBox.getSelectedItem().toString();
                    if (attribVal.equals(DEFAULT_SELECTION_STRING)) attribVal = "";
                }
                
                //after obtaining the node name and name attribute of the current node,
                //  decide it is an intermediate node or an end target whoes values are to be displayed
                if(nodeName.equals(finalNodeName)) {
                    //remember the name of the parent of the node whose value
                    //  will be displayed in the left-side header
                    
                    String lefterName = currNode.toLefterString();
                    String prevName;
                    if (!lefter.isEmpty()) {
                        prevName = (String)lefter.lastElement();
                        if (!(prevName.equals(lefterName))) lefter.add(lefterName);
                    } else lefter.add(lefterName);
                    
                    //for nodes directly under a period node
                    String oldName = currNode.toString();
                    int index1 = oldName.indexOf('<');
                    int index2 = oldName.indexOf('>');
                    if (oldName.substring(index1+1, index2).equals("period")) {
                        //remember the last index in values that contains confirmed entry
                        int lastValIndex = values.size();
                        
                        //fill values with appropriate number of empty nodes
                        int numPeriods = modelTime.getNumOfSteps();
                        for (int k = 0; k < numPeriods; k++) {
                            values.addElement(new AdapterNode());
                            
                            attribVal = modelTime.getYear(k);
                            if (header.isEmpty()) header.addElement(attribVal);
                            else if (!header.contains(attribVal)) header.addElement(attribVal);
                        }
                        
                        //get a list of all period nodes in that subtree
                        int offset = 0;
                        AdapterNode parent = currNode.getParent();
                        childNodes = parent.getChildren("period", "");
                        Iterator it = childNodes.iterator();
                        while (it.hasNext()) {
                            //for each period node, get the value of the "final node" under it,
                            //  remember the period node's year attribute
                            parent = (AdapterNode)it.next();
                            currNode = parent.getChild(nodeName, "");
                            
                            attribVal = parent.getAttributeValue("year");
                            offset = modelTime.getYearIndex(attribVal);
                            if (showNames) {
                                values.setElementAt(currNode.getAttributeValue("name"), lastValIndex+offset);
                            } else {
                                values.setElementAt(currNode, lastValIndex+offset);
                            }
                        }
                        
                    } else {        //if parent of desired node(s) isn't "period"
                        
                        Integer lastYear = new Integer(modelTime.getStart());
                        Vector years = modelTime.getTimeIntervals();
                        Iterator yearIt = years.iterator();
                        boolean demographics = false;
                        
                        if (attribVal.equals(DEFAULT_PLURAL_STRING)) attribVal = "";
                        childNodes = currNode.getChildren(nodeName, attribVal);
                        Iterator it = childNodes.iterator();
                        
                        //SPECIAL CASE: nodes under demographics begin with year=1960, not 1975
                        //assume that all values are present
                        if (currNode.getName().equals("demographics")) {
                            demographics = true;
                        }
                        
                        //adds blank values for nodes are not present in a subtree
                        //  but whose parent's name is already added to lefter
                        if (!it.hasNext()) {
                            if (timeInterval) {
                                int numPeriods = modelTime.getNumOfSteps();
                                for (int k = 0; k < numPeriods; k++) {
                                    values.addElement(new AdapterNode());
                                }
                            } else
                                values.addElement(new AdapterNode());
                        }
                        
                        timeInterval = false;
                        
                        while (it.hasNext()) {
                            currNode = (AdapterNode)it.next();
                            if (showNames) {
                                values.addElement(currNode.getAttributeValue("name"));
                            } else {
                                attribVal = currNode.getAttributeValue("year");
                                if (attribVal != null) {
                                    if (demographics) {
                                        if (header.isEmpty()) header.addElement(attribVal);
                                        else if (!header.contains(attribVal)) header.addElement(attribVal);
                                    } else {
                                        timeInterval = true;
                                        //if node has year, make sure that values are saved under proper year
                                        Integer attribYear = new Integer(attribVal);
                                        Integer currYear = (Integer)yearIt.next();
                                        
                                        while (!attribYear.equals(currYear)) {
                                            if (header.isEmpty()) header.addElement(currYear.toString());
                                            else if (!header.contains(currYear.toString())) header.addElement(currYear.toString());
                                            values.addElement(new AdapterNode());
                                            if (yearIt.hasNext())currYear = (Integer)yearIt.next();
                                            else break;
                                        }
                                        
                                        if (header.isEmpty()) header.addElement(currYear.toString());
                                        else if (!header.contains(currYear.toString())) header.addElement(currYear.toString());
                                        lastYear = currYear;
                                    }
                                }
                                
                                values.addElement(currNode);
                            }
                        }
                        while (timeInterval && !lastYear.equals(new Integer(modelTime.getEnd()))) {
                            lastYear = (Integer)yearIt.next();
                            if (header.isEmpty()) header.addElement(lastYear.toString());
                            else if (!header.contains(lastYear.toString())) header.addElement(lastYear.toString());
                            values.addElement(new AdapterNode());
                        }
                    }
                } else {    //current node is an intermediate step along the tree
                    if(attribVal.equals(DEFAULT_PLURAL_STRING)) {
                        //get all chidren and add to the queue for examination
                        childNodes = currNode.getChildren(nodeName, "");
                        Iterator it = childNodes.iterator();
                        while (it.hasNext()) {
                            currNode = (AdapterNode)it.next();
                            currNode.setIndex(index+1);
                            queue.addElement(currNode);
                        }
                    } else {
                        //get child with target name attribute and add it to the queue for examination
                        currNode = currNode.getChild(nodeName, attribVal);
                        currNode.setIndex(index+1);
                        queue.addElement(currNode);
                    }
                }
            } //belongs to while (!queue.isEmpty())
        } //belongs to for each region
        
//System.out.println("values  = " + values.size() + " header = " + header.size() + " lefter = " + lefter.size());
        
        TableViewModel model = new TableViewModel(values, header, lefter, showNames);
        table = new JTable(model);
        table.setCellSelectionEnabled(true);
        table.setTransferHandler(new TableTransferHandler());
	  table.setAutoResizeMode( JTable.AUTO_RESIZE_ALL_COLUMNS );
        
        //use panels to place the table appropriately
        JPanel tempPanel = new JPanel();
        tempPanel.setLayout(new BorderLayout());
        tempPanel.add(table.getTableHeader(), BorderLayout.NORTH);
        tempPanel.add(table, BorderLayout.CENTER);
        
        JPanel tempPanel2 = new JPanel();
        tempPanel2.setLayout(new BorderLayout());
        if (!lefter.isEmpty()) {
            //JPanel lefterPanel = makeLefter(lefter, nodeName);
            lefter = model.getTableLefter();
            JPanel lefterPanel = makeLefter(lefter, finalNodeName);
            tempPanel2.add(lefterPanel, BorderLayout.WEST);
        }
        tempPanel2.add(tempPanel, BorderLayout.CENTER);
        
        //dataPanel.add(Box.createRigidArea(new Dimension(0,10)));
        dataPanel.add(tempPanel2);
        
        tableExistsFlag = true;
        
        dataPanel.revalidate();
        repaint();
        //}
    }
    
    public void makeAddChildPanel() {
        addChildDialog = new JDialog(this, "Add child node", true);
        addChildDialog.getContentPane().setLayout(new BoxLayout(addChildDialog.getContentPane(), BoxLayout.X_AXIS));
        
        nameField = new JTextField();
        attribField = new JTextField();
        valueField = new JTextField();
        
        JPanel childPanel = new JPanel();
        childPanel.setLayout(new BoxLayout(childPanel, BoxLayout.Y_AXIS));
        childPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 5, 5));
        
        JLabel nameLabel = new JLabel("Node Name (required): ");
        childPanel.add(nameLabel);
        childPanel.add(Box.createRigidArea(new Dimension(0, 3)));
        childPanel.add(nameField);
        childPanel.add(Box.createRigidArea(new Dimension(0, 15)));
        
        JLabel attribLabel = new JLabel("Node Attribute(s) (optional list in the form name=node name, year=1975");
        childPanel.add(attribLabel);
        childPanel.add(Box.createRigidArea(new Dimension(0, 3)));
        childPanel.add(attribField);
        childPanel.add(Box.createRigidArea(new Dimension(0, 15)));
        
        JLabel valueLabel = new JLabel("Node Value ");
        childPanel.add(valueLabel);
        childPanel.add(Box.createRigidArea(new Dimension(0, 3)));
        childPanel.add(valueField);
        childPanel.add(Box.createRigidArea(new Dimension(0, 15)));
        
        addChildDialog.getContentPane().add(childPanel);
        
        
        locationPanel = new JPanel();
        locationPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
        addChildDialog.getContentPane().add(locationPanel);
        
        
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(0,1,5,5));
        //buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));
        
        JButton addNodeButton = new JButton("Add Node");
        //addNodeButton.setMaximumSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
        //addNodeButton.setPreferredSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
        addNodeButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                addChildNode();
                hideAddChildDialog();
            }
        });
        
        JButton cancelButton = new JButton("Cancel");
        //cancelButton.setMaximumSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
        //cancelButton.setPreferredSize(new Dimension(100, DEFAULT_COMPONENT_HEIGHT));
        //cancelButton.setPreferredSize(new Dimension(100, 25));
        //cancelButton.setMinimumSize(new Dimension(100, 25));
        cancelButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                hideAddChildDialog();
            }
        });
        
        JButton addAllButton = new JButton("Add Everywhere");
        addAllButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                addChildrenNodes();
                hideAddChildDialog();
            }
        });
        
        buttonPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
        buttonPanel.add(addNodeButton);
        //buttonPanel.add(Box.createRigidArea(new Dimension(5,5)));
        buttonPanel.add(cancelButton);
        buttonPanel.add(addAllButton);
        buttonPanel.add(Box.createVerticalGlue());
        
        JPanel tempPanel = new JPanel();
        tempPanel.setLayout(new BoxLayout(tempPanel, BoxLayout.X_AXIS));
        tempPanel.add(new JSeparator(SwingConstants.VERTICAL));
        tempPanel.add(buttonPanel);
        //tempPanel.add(Box.createVerticalGlue());
        
        addChildDialog.getContentPane().add(tempPanel);
    }
    
    private AdapterNode extractNewChild() {
        String nodeName = nameField.getText().trim();
        String attribs = attribField.getText().trim();
        String value = valueField.getText().trim();
        int sIndex, eIndex, index;
        
        //create new node with given name
        AdapterNode newNode = new AdapterNode(nodeName);
        
        //add all attributes to the new node, if the exist
        //  assumes a comma-seporated list of attributes in the form: name=nodeName, year=1975, ...
        if (attribs.length() > 0) {
            eIndex = attribs.indexOf(',');
            sIndex = 0;
            String attrib, val;
            while (eIndex > 0) {
                attrib = attribs.substring(sIndex, eIndex);
                index = attrib.indexOf('=');
                val = attrib.substring(index+1).trim();
                attrib = attrib.substring(0, index).trim();
                newNode.setAttribute(attrib, val);
                
                sIndex = eIndex + 1;
                eIndex = attribs.indexOf(',', sIndex);
            }
            attrib = attribs.substring(sIndex);
            index = attrib.indexOf('=');
            val = attrib.substring(index+1).trim();
            attrib = attrib.substring(0, index).trim();
            newNode.setAttribute(attrib, val);
        }
        
        if (value.length() > 0) {
            newNode.setText(value);
        }
        
        return newNode;
    }
    
    private void addChildNode() {
        //build the new child from info entered into Add Child dialog
        AdapterNode newChild = extractNewChild();
        
        JDomToTreeModelAdapter model = (JDomToTreeModelAdapter)tree.getModel();
        model.insertNodeInto(newChild, selectedPath, 0);
    }
    
    private void addChildrenNodes() {
        //build the new child from info entered into Add Child dialog
        AdapterNode newNode = extractNewChild();
        
        JDomToTreeModelAdapter model = (JDomToTreeModelAdapter)tree.getModel();
        
        AdapterNode pathStep;
        Object[] pathNodes = selectedPath.getPath();
        
        //Vector queue = new Vector();
        Vector addedPaths = new Vector();
        
        //get a string representation of the path with just node names, not attributes
        String targetNodeNames = "";
        String targetLastName = "";
        for (int j = 0; j < pathNodes.length; j++) {
            pathStep = (AdapterNode)pathNodes[j];
            targetLastName = pathStep.getName();
            targetNodeNames += targetLastName;
        }
        
        Vector futureParents = new Vector();
        searchTree((AdapterNode)model.getRoot(), targetLastName, futureParents);
        
        //add newChild to every unique parent in futureParents
        Vector parentPathNodes = new Vector();
        TreePath parentPath;
        Iterator it = futureParents.iterator();
        AdapterNode parent;
        while (it.hasNext()) {
            parentPathNodes.clear();
            parent = (AdapterNode)it.next();
            while (parent != null) {
                parentPathNodes.add(0, parent);
                parent = parent.getParent();
            }
            
            parentPath = new TreePath(parentPathNodes.toArray());
            if (!addedPaths.contains(parentPath)) {
                model.insertNodeInto((AdapterNode)newNode.clone(), parentPath, 0);
                addedPaths.addElement(parentPath);
            }
        }
    }
    
    private void searchTree(AdapterNode currNode, String targetName, Vector futureParents) {
        if (currNode.getName().equals(targetName)) {
            futureParents.addElement(currNode);
            return;
        }
        
        java.util.List children = currNode.getChildren();
        Iterator it = children.iterator();
        while (it.hasNext()) {
            searchTree((AdapterNode)it.next(), targetName, futureParents);
        }
    }
    
    //display the add dialog box
    private void showAddChildDialog() {
        nameField.setText("");
        attribField.setText("");
        valueField.setText("");
        
        //display possible locations where to add node
        
        
        addChildDialog.pack();
        //center above the main window
        addChildDialog.setLocationRelativeTo(addChildDialog.getParent());
        addChildDialog.show();
    }
    
    private void hideAddChildDialog() {
        addChildDialog.hide();
    }
    
    private void deleteNode() {
        AdapterNode currNode = (AdapterNode)selectedPath.getLastPathComponent();
        String message = "Are you sure you want to delete this node";
        
        if (currNode.isLeaf()) {
            message += "?";
        } else {
            message += " and all its children?";
        }
        
        int ans = JOptionPane.showConfirmDialog(this, message, "Delete Node", JOptionPane.YES_NO_OPTION);
        
        if (ans == JOptionPane.NO_OPTION) return;
        
        //delete the node
        JDomToTreeModelAdapter model = (JDomToTreeModelAdapter)tree.getModel();
        model.removeNodeFrom(selectedPath);   
    }
       
    protected void makeNewThread() {
        Thread newThread = new Thread() {
            public void run() {
                Object[] pathNodes = selectedPath.getPath();
                int j = 0;
                AdapterNode currNode = (AdapterNode)pathNodes[j];
                while (j-1 < pathNodes.length && !currNode.getName().equals("region")) {
                    currNode = (AdapterNode)pathNodes[j++];
                } 

                if (!currNode.getName().equals("region")) {
                    System.out.println("Can't show table, no region node found");
                    return;
                }

                if (regionBox == null) displayRegionBox();
                regionBox.setSelectedValue(currNode.getAttributeValue("name"), true);
                yield();

                int index = 1;
                JComboBox tempBox;
                String attrib;
                for (int k = j; k < pathNodes.length; k++) {
                    currNode = (AdapterNode)pathNodes[k];
                    tempBox = (JComboBox)queryControls.elementAt(index);
                    tempBox.setSelectedItem(currNode.getName());
                    yield();

                    attrib = currNode.getAttributeValue("name");
                    if (attrib != null) {
                        tempBox = (JComboBox)attributeControls.elementAt(index);
                        tempBox.setSelectedItem(attrib);
                        if (!tempBox.getSelectedItem().toString().equals(attrib)) {
                            tempBox.setSelectedItem(DEFAULT_PLURAL_STRING);
                        }
                    }
                    yield();

                    index++;            
                }
                if (currNode.getText() != null) showTable();
            }
            
        };
        newThread.start();
    }
    
    private void saveFile() {
        XMLOutputter outputter = new XMLOutputter();
        
        int returnVal = fc.showSaveDialog(this.getContentPane());
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            
            /*//determine whether the file is to be an xml or zip
            String fileName = file.toString();
            boolean zipping = false;
            int index = fileName.lastIndexOf('.');
            if (index > 0) {
                if (fileName.substring(index+1).equals("zip")) zipping = true;
            }*/
            
            try {
                //if (!zipping) {
//System.out.println("saving");
                    outputter.output(document, new FileOutputStream(file));
                    //nodeValueChangedFlag = false;
                //} else {*/
/*System.out.println("writing 1 " + file.toString());


                    
                    byte[] buf = new byte[1024];
                    int len;
                    ZipEntry zipEntry = new ZipEntry(file.toString());
                    FileInputStream fin = new FileInputStream(file);
                    BufferedInputStream in = new BufferedInputStream(fin);
                    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream("c:\\new.zip"));
                    zos.putNextEntry(zipEntry);
                    while ((len = in.read(buf, 0, 1024)) != -1)
                    {
                       zos.write(buf, 0, len);
                    }
                    
                    zipEntry.setSize(file.length());
                    zos.closeEntry();
                    //Close the input stream.
                    in.close();*/


                    nodeValueChangedFlag = false;
//System.out.println("done");
                //}
            } catch (Exception e) {
                System.err.println(e);
            }
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
}